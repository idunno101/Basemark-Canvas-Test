/*
 * 0.1.0: Copyright (c) 2006-2007 Erin Catto http://box2d-js.sourceforge.net/
 * 0.2.0:
 *     Created by rene7705@gmail.com, http://mediabeez.ws/downloads/
 *     purpose: replace prototype dependency with jquery dependency
 *     Copyright (c) 2010 Erin Catto
 *
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 * 1. The origin of this software must not be misrepresented; you must not
 * claim that you wrote the original software. If you use this software
 * in a product, an acknowledgment in the product documentation would be
 * appreciated but is not required.
 * 2. Altered source versions must be plainly marked, and must not be
 * misrepresented the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */
var b2Root = function () {
    function t() {
      this.initialize.apply(this, arguments);
    }
    return t;
  },
  b2Settings = new b2Root();
jQuery.extend(b2Settings.prototype, { initialize: function () {} }),
  (b2Settings.USHRT_MAX = 65535),
  (b2Settings.b2_pi = Math.PI),
  (b2Settings.b2_massUnitsPerKilogram = 1),
  (b2Settings.b2_timeUnitsPerSecond = 1),
  (b2Settings.b2_lengthUnitsPerMeter = 30),
  (b2Settings.b2_maxManifoldPoints = 2),
  (b2Settings.b2_maxShapesPerBody = 64),
  (b2Settings.b2_maxPolyVertices = 8),
  (b2Settings.b2_maxProxies = 1024),
  (b2Settings.b2_maxPairs = 8 * b2Settings.b2_maxProxies),
  (b2Settings.b2_linearSlop = 0.005 * b2Settings.b2_lengthUnitsPerMeter),
  (b2Settings.b2_angularSlop = (2 / 180) * b2Settings.b2_pi),
  (b2Settings.b2_velocityThreshold =
    (1 * b2Settings.b2_lengthUnitsPerMeter) / b2Settings.b2_timeUnitsPerSecond),
  (b2Settings.b2_maxLinearCorrection = 0.2 * b2Settings.b2_lengthUnitsPerMeter),
  (b2Settings.b2_maxAngularCorrection = (8 / 180) * b2Settings.b2_pi),
  (b2Settings.b2_contactBaumgarte = 0.2),
  (b2Settings.b2_timeToSleep = 0.5 * b2Settings.b2_timeUnitsPerSecond),
  (b2Settings.b2_linearSleepTolerance =
    (0.01 * b2Settings.b2_lengthUnitsPerMeter) /
    b2Settings.b2_timeUnitsPerSecond),
  (b2Settings.b2_angularSleepTolerance =
    2 / 180 / b2Settings.b2_timeUnitsPerSecond),
  (b2Settings.b2Assert = function (t) {
    if (!t) {
      var i;
      i.x++;
    }
  });
var b2Vec2 = new b2Root();
jQuery.extend(b2Vec2.prototype, {
  initialize: function (t, i) {
    (this.x = t), (this.y = i);
  },
  SetZero: function () {
    (this.x = 0), (this.y = 0);
  },
  Set: function (t, i) {
    (this.x = t), (this.y = i);
  },
  SetV: function (t) {
    (this.x = t.x), (this.y = t.y);
  },
  Negative: function () {
    return new b2Vec2(-this.x, -this.y);
  },
  Copy: function () {
    return new b2Vec2(this.x, this.y);
  },
  Add: function (t) {
    (this.x += t.x), (this.y += t.y);
  },
  Subtract: function (t) {
    (this.x -= t.x), (this.y -= t.y);
  },
  Multiply: function (t) {
    (this.x *= t), (this.y *= t);
  },
  MulM: function (t) {
    var i = this.x;
    (this.x = t.col1.x * i + t.col2.x * this.y),
      (this.y = t.col1.y * i + t.col2.y * this.y);
  },
  MulTM: function (t) {
    var i = b2Math.b2Dot(this, t.col1);
    (this.y = b2Math.b2Dot(this, t.col2)), (this.x = i);
  },
  CrossVF: function (t) {
    var i = this.x;
    (this.x = t * this.y), (this.y = -t * i);
  },
  CrossFV: function (t) {
    var i = this.x;
    (this.x = -t * this.y), (this.y = t * i);
  },
  MinV: function (t) {
    (this.x = this.x < t.x ? this.x : t.x),
      (this.y = this.y < t.y ? this.y : t.y);
  },
  MaxV: function (t) {
    (this.x = this.x > t.x ? this.x : t.x),
      (this.y = this.y > t.y ? this.y : t.y);
  },
  Abs: function () {
    (this.x = Math.abs(this.x)), (this.y = Math.abs(this.y));
  },
  Length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  Normalize: function () {
    var t = this.Length();
    if (t < Number.MIN_VALUE) return 0;
    var i = 1 / t;
    return (this.x *= i), (this.y *= i), t;
  },
  IsValid: function () {
    return b2Math.b2IsValid(this.x) && b2Math.b2IsValid(this.y);
  },
  x: null,
  y: null,
}),
  (b2Vec2.Make = function (t, i) {
    return new b2Vec2(t, i);
  });
var b2Mat22 = new b2Root();
jQuery.extend(b2Mat22.prototype, {
  initialize: function (t, i, o) {
    if (
      (null == t && (t = 0),
      (this.col1 = new b2Vec2()),
      (this.col2 = new b2Vec2()),
      null != i && null != o)
    )
      this.col1.SetV(i), this.col2.SetV(o);
    else {
      var n = Math.cos(t),
        e = Math.sin(t);
      (this.col1.x = n),
        (this.col2.x = -e),
        (this.col1.y = e),
        (this.col2.y = n);
    }
  },
  Set: function (t) {
    var i = Math.cos(t),
      o = Math.sin(t);
    (this.col1.x = i), (this.col2.x = -o), (this.col1.y = o), (this.col2.y = i);
  },
  SetVV: function (t, i) {
    this.col1.SetV(t), this.col2.SetV(i);
  },
  Copy: function () {
    return new b2Mat22(0, this.col1, this.col2);
  },
  SetM: function (t) {
    this.col1.SetV(t.col1), this.col2.SetV(t.col2);
  },
  AddM: function (t) {
    (this.col1.x += t.col1.x),
      (this.col1.y += t.col1.y),
      (this.col2.x += t.col2.x),
      (this.col2.y += t.col2.y);
  },
  SetIdentity: function () {
    (this.col1.x = 1), (this.col2.x = 0), (this.col1.y = 0), (this.col2.y = 1);
  },
  SetZero: function () {
    (this.col1.x = 0), (this.col2.x = 0), (this.col1.y = 0), (this.col2.y = 0);
  },
  Invert: function (t) {
    var i = this.col1.x,
      o = this.col2.x,
      n = this.col1.y,
      e = this.col2.y,
      s = i * e - o * n;
    return (
      (s = 1 / s),
      (t.col1.x = s * e),
      (t.col2.x = -s * o),
      (t.col1.y = -s * n),
      (t.col2.y = s * i),
      t
    );
  },
  Solve: function (t, i, o) {
    var n = this.col1.x,
      e = this.col2.x,
      s = this.col1.y,
      a = this.col2.y,
      l = n * a - e * s;
    return (
      (l = 1 / l), (t.x = l * (a * i - e * o)), (t.y = l * (n * o - s * i)), t
    );
  },
  Abs: function () {
    this.col1.Abs(), this.col2.Abs();
  },
  col1: new b2Vec2(),
  col2: new b2Vec2(),
});
var b2Math = new b2Root();
jQuery.extend(b2Math.prototype, { initialize: function () {} }),
  (b2Math.b2IsValid = function (t) {
    return isFinite(t);
  }),
  (b2Math.b2Dot = function (t, i) {
    return t.x * i.x + t.y * i.y;
  }),
  (b2Math.b2CrossVV = function (t, i) {
    return t.x * i.y - t.y * i.x;
  }),
  (b2Math.b2CrossVF = function (t, i) {
    var o = new b2Vec2(i * t.y, -i * t.x);
    return o;
  }),
  (b2Math.b2CrossFV = function (t, i) {
    var o = new b2Vec2(-t * i.y, t * i.x);
    return o;
  }),
  (b2Math.b2MulMV = function (t, i) {
    var o = new b2Vec2(
      t.col1.x * i.x + t.col2.x * i.y,
      t.col1.y * i.x + t.col2.y * i.y
    );
    return o;
  }),
  (b2Math.b2MulTMV = function (t, i) {
    var o = new b2Vec2(b2Math.b2Dot(i, t.col1), b2Math.b2Dot(i, t.col2));
    return o;
  }),
  (b2Math.AddVV = function (t, i) {
    var o = new b2Vec2(t.x + i.x, t.y + i.y);
    return o;
  }),
  (b2Math.SubtractVV = function (t, i) {
    var o = new b2Vec2(t.x - i.x, t.y - i.y);
    return o;
  }),
  (b2Math.MulFV = function (t, i) {
    var o = new b2Vec2(t * i.x, t * i.y);
    return o;
  }),
  (b2Math.AddMM = function (t, i) {
    var o = new b2Mat22(
      0,
      b2Math.AddVV(t.col1, i.col1),
      b2Math.AddVV(t.col2, i.col2)
    );
    return o;
  }),
  (b2Math.b2MulMM = function (t, i) {
    var o = new b2Mat22(
      0,
      b2Math.b2MulMV(t, i.col1),
      b2Math.b2MulMV(t, i.col2)
    );
    return o;
  }),
  (b2Math.b2MulTMM = function (t, i) {
    var o = new b2Vec2(
        b2Math.b2Dot(t.col1, i.col1),
        b2Math.b2Dot(t.col2, i.col1)
      ),
      n = new b2Vec2(
        b2Math.b2Dot(t.col1, i.col2),
        b2Math.b2Dot(t.col2, i.col2)
      ),
      e = new b2Mat22(0, o, n);
    return e;
  }),
  (b2Math.b2Abs = function (t) {
    return t > 0 ? t : -t;
  }),
  (b2Math.b2AbsV = function (t) {
    var i = new b2Vec2(b2Math.b2Abs(t.x), b2Math.b2Abs(t.y));
    return i;
  }),
  (b2Math.b2AbsM = function (t) {
    var i = new b2Mat22(0, b2Math.b2AbsV(t.col1), b2Math.b2AbsV(t.col2));
    return i;
  }),
  (b2Math.b2Min = function (t, i) {
    return i > t ? t : i;
  }),
  (b2Math.b2MinV = function (t, i) {
    var o = new b2Vec2(b2Math.b2Min(t.x, i.x), b2Math.b2Min(t.y, i.y));
    return o;
  }),
  (b2Math.b2Max = function (t, i) {
    return t > i ? t : i;
  }),
  (b2Math.b2MaxV = function (t, i) {
    var o = new b2Vec2(b2Math.b2Max(t.x, i.x), b2Math.b2Max(t.y, i.y));
    return o;
  }),
  (b2Math.b2Clamp = function (t, i, o) {
    return b2Math.b2Max(i, b2Math.b2Min(t, o));
  }),
  (b2Math.b2ClampV = function (t, i, o) {
    return b2Math.b2MaxV(i, b2Math.b2MinV(t, o));
  }),
  (b2Math.b2Swap = function (t, i) {
    var o = t[0];
    (t[0] = i[0]), (i[0] = o);
  }),
  (b2Math.b2Random = function () {
    return 2 * Math.random() - 1;
  }),
  (b2Math.b2NextPowerOfTwo = function (t) {
    return (
      (t |= (t >> 1) & 2147483647),
      (t |= (t >> 2) & 1073741823),
      (t |= (t >> 4) & 268435455),
      (t |= (t >> 8) & 16777215),
      (t |= (t >> 16) & 65535),
      t + 1
    );
  }),
  (b2Math.b2IsPowerOfTwo = function (t) {
    var i = t > 0 && 0 == (t & (t - 1));
    return i;
  }),
  (b2Math.tempVec2 = new b2Vec2()),
  (b2Math.tempVec3 = new b2Vec2()),
  (b2Math.tempVec4 = new b2Vec2()),
  (b2Math.tempVec5 = new b2Vec2()),
  (b2Math.tempMat = new b2Mat22());
var b2ShapeDef = new b2Root();
jQuery.extend(b2ShapeDef.prototype, {
  initialize: function () {
    (this.type = b2Shape.e_unknownShape),
      (this.userData = null),
      (this.localPosition = new b2Vec2(0, 0)),
      (this.localRotation = 0),
      (this.friction = 0.2),
      (this.restitution = 0),
      (this.density = 0),
      (this.categoryBits = 1),
      (this.maskBits = 65535),
      (this.groupIndex = 0);
  },
  ComputeMass: function (t) {
    switch (
      ((t.center = new b2Vec2(0, 0)),
      0 == this.density && ((t.mass = 0), t.center.Set(0, 0), (t.I = 0)),
      this.type)
    ) {
      case b2Shape.e_circleShape:
        var i = this;
        (t.mass = this.density * b2Settings.b2_pi * i.radius * i.radius),
          t.center.Set(0, 0),
          (t.I = 0.5 * t.mass * i.radius * i.radius);
        break;
      case b2Shape.e_boxShape:
        var o = this;
        (t.mass = 4 * this.density * o.extents.x * o.extents.y),
          t.center.Set(0, 0),
          (t.I = (t.mass / 3) * b2Math.b2Dot(o.extents, o.extents));
        break;
      case b2Shape.e_polyShape:
        var n = this;
        b2Shape.PolyMass(t, n.vertices, n.vertexCount, this.density);
        break;
      default:
        (t.mass = 0), t.center.Set(0, 0), (t.I = 0);
    }
  },
  type: 0,
  userData: null,
  localPosition: null,
  localRotation: null,
  friction: null,
  restitution: null,
  density: null,
  categoryBits: 0,
  maskBits: 0,
  groupIndex: 0,
});
var b2Shape = new b2Root();
jQuery.extend(b2Shape.prototype, {
  TestPoint: function (t) {
    return !1;
  },
  GetUserData: function () {
    return this.m_userData;
  },
  GetType: function () {
    return this.m_type;
  },
  GetBody: function () {
    return this.m_body;
  },
  GetPosition: function () {
    return this.m_position;
  },
  GetRotationMatrix: function () {
    return this.m_R;
  },
  ResetProxy: function (t) {},
  GetNext: function () {
    return this.m_next;
  },
  initialize: function (t, i) {
    (this.m_R = new b2Mat22()),
      (this.m_position = new b2Vec2()),
      (this.m_userData = t.userData),
      (this.m_friction = t.friction),
      (this.m_restitution = t.restitution),
      (this.m_body = i),
      (this.m_proxyId = b2Pair.b2_nullProxy),
      (this.m_maxRadius = 0),
      (this.m_categoryBits = t.categoryBits),
      (this.m_maskBits = t.maskBits),
      (this.m_groupIndex = t.groupIndex);
  },
  DestroyProxy: function () {
    this.m_proxyId != b2Pair.b2_nullProxy &&
      (this.m_body.m_world.m_broadPhase.DestroyProxy(this.m_proxyId),
      (this.m_proxyId = b2Pair.b2_nullProxy));
  },
  Synchronize: function (t, i, o, n) {},
  QuickSync: function (t, i) {},
  Support: function (t, i, o) {},
  GetMaxRadius: function () {
    return this.m_maxRadius;
  },
  m_next: null,
  m_R: new b2Mat22(),
  m_position: new b2Vec2(),
  m_type: 0,
  m_userData: null,
  m_body: null,
  m_friction: null,
  m_restitution: null,
  m_maxRadius: null,
  m_proxyId: 0,
  m_categoryBits: 0,
  m_maskBits: 0,
  m_groupIndex: 0,
}),
  (b2Shape.Create = function (t, i, o) {
    switch (t.type) {
      case b2Shape.e_circleShape:
        return new b2CircleShape(t, i, o);
      case b2Shape.e_boxShape:
      case b2Shape.e_polyShape:
        return new b2PolyShape(t, i, o);
    }
    return null;
  }),
  (b2Shape.Destroy = function (t) {
    t.m_proxyId != b2Pair.b2_nullProxy &&
      t.m_body.m_world.m_broadPhase.DestroyProxy(t.m_proxyId);
  }),
  (b2Shape.e_unknownShape = -1),
  (b2Shape.e_circleShape = 0),
  (b2Shape.e_boxShape = 1),
  (b2Shape.e_polyShape = 2),
  (b2Shape.e_meshShape = 3),
  (b2Shape.e_shapeTypeCount = 4),
  (b2Shape.PolyMass = function (t, i, o, n) {
    var e = new b2Vec2();
    e.SetZero();
    for (var s = 0, a = 0, l = new b2Vec2(0, 0), r = 1 / 3, m = 0; o > m; ++m) {
      var _ = l,
        h = i[m],
        c = o > m + 1 ? i[m + 1] : i[0],
        u = b2Math.SubtractVV(h, _),
        y = b2Math.SubtractVV(c, _),
        b = b2Math.b2CrossVV(u, y),
        p = 0.5 * b;
      s += p;
      var x = new b2Vec2();
      x.SetV(_), x.Add(h), x.Add(c), x.Multiply(r * p), e.Add(x);
      var d = _.x,
        v = _.y,
        f = u.x,
        g = u.y,
        M = y.x,
        V = y.y,
        S =
          r * (0.25 * (f * f + M * f + M * M) + (d * f + d * M)) + 0.5 * d * d,
        C =
          r * (0.25 * (g * g + V * g + V * V) + (v * g + v * V)) + 0.5 * v * v;
      a += b * (S + C);
    }
    (t.mass = n * s),
      e.Multiply(1 / s),
      (t.center = e),
      (a = n * (a - s * b2Math.b2Dot(e, e))),
      (t.I = a);
  }),
  (b2Shape.PolyCentroid = function (t, i, o) {
    for (var n = 0, e = 0, s = 0, a = 0, l = 0, r = 1 / 3, m = 0; i > m; ++m) {
      var _ = a,
        h = l,
        c = t[m].x,
        u = t[m].y,
        y = i > m + 1 ? t[m + 1].x : t[0].x,
        b = i > m + 1 ? t[m + 1].y : t[0].y,
        p = c - _,
        x = u - h,
        d = y - _,
        v = b - h,
        f = p * v - x * d,
        g = 0.5 * f;
      (s += g), (n += g * r * (_ + c + y)), (e += g * r * (h + u + b));
    }
    (n *= 1 / s), (e *= 1 / s), o.Set(n, e);
  });
var b2BoxDef = new b2Root();
jQuery.extend(b2BoxDef.prototype, b2ShapeDef.prototype),
  jQuery.extend(b2BoxDef.prototype, {
    initialize: function () {
      (this.type = b2Shape.e_unknownShape),
        (this.userData = null),
        (this.localPosition = new b2Vec2(0, 0)),
        (this.localRotation = 0),
        (this.friction = 0.2),
        (this.restitution = 0),
        (this.density = 0),
        (this.categoryBits = 1),
        (this.maskBits = 65535),
        (this.groupIndex = 0),
        (this.type = b2Shape.e_boxShape),
        (this.extents = new b2Vec2(1, 1));
    },
    extents: null,
  });
var b2CircleDef = new b2Root();
jQuery.extend(b2CircleDef.prototype, b2ShapeDef.prototype),
  jQuery.extend(b2CircleDef.prototype, {
    initialize: function () {
      (this.type = b2Shape.e_unknownShape),
        (this.userData = null),
        (this.localPosition = new b2Vec2(0, 0)),
        (this.localRotation = 0),
        (this.friction = 0.2),
        (this.restitution = 0),
        (this.density = 0),
        (this.categoryBits = 1),
        (this.maskBits = 65535),
        (this.groupIndex = 0),
        (this.type = b2Shape.e_circleShape),
        (this.radius = 1);
    },
    radius: null,
  });
var b2CircleShape = new b2Root();
jQuery.extend(b2CircleShape.prototype, b2Shape.prototype),
  jQuery.extend(b2CircleShape.prototype, {
    TestPoint: function (t) {
      var i = new b2Vec2();
      return (
        i.SetV(t),
        i.Subtract(this.m_position),
        b2Math.b2Dot(i, i) <= this.m_radius * this.m_radius
      );
    },
    initialize: function (t, i, o) {
      (this.m_R = new b2Mat22()),
        (this.m_position = new b2Vec2()),
        (this.m_userData = t.userData),
        (this.m_friction = t.friction),
        (this.m_restitution = t.restitution),
        (this.m_body = i),
        (this.m_proxyId = b2Pair.b2_nullProxy),
        (this.m_maxRadius = 0),
        (this.m_categoryBits = t.categoryBits),
        (this.m_maskBits = t.maskBits),
        (this.m_groupIndex = t.groupIndex),
        (this.m_localPosition = new b2Vec2());
      var n = t;
      this.m_localPosition.Set(
        t.localPosition.x - o.x,
        t.localPosition.y - o.y
      ),
        (this.m_type = b2Shape.e_circleShape),
        (this.m_radius = n.radius),
        this.m_R.SetM(this.m_body.m_R);
      var e =
          this.m_R.col1.x * this.m_localPosition.x +
          this.m_R.col2.x * this.m_localPosition.y,
        s =
          this.m_R.col1.y * this.m_localPosition.x +
          this.m_R.col2.y * this.m_localPosition.y;
      (this.m_position.x = this.m_body.m_position.x + e),
        (this.m_position.y = this.m_body.m_position.y + s),
        (this.m_maxRadius = Math.sqrt(e * e + s * s) + this.m_radius);
      var a = new b2AABB();
      a.minVertex.Set(
        this.m_position.x - this.m_radius,
        this.m_position.y - this.m_radius
      ),
        a.maxVertex.Set(
          this.m_position.x + this.m_radius,
          this.m_position.y + this.m_radius
        );
      var l = this.m_body.m_world.m_broadPhase;
      l.InRange(a)
        ? (this.m_proxyId = l.CreateProxy(a, this))
        : (this.m_proxyId = b2Pair.b2_nullProxy),
        this.m_proxyId == b2Pair.b2_nullProxy && this.m_body.Freeze();
    },
    Synchronize: function (t, i, o, n) {
      if (
        (this.m_R.SetM(n),
        (this.m_position.x =
          n.col1.x * this.m_localPosition.x +
          n.col2.x * this.m_localPosition.y +
          o.x),
        (this.m_position.y =
          n.col1.y * this.m_localPosition.x +
          n.col2.y * this.m_localPosition.y +
          o.y),
        this.m_proxyId != b2Pair.b2_nullProxy)
      ) {
        var e =
            t.x +
            (i.col1.x * this.m_localPosition.x +
              i.col2.x * this.m_localPosition.y),
          s =
            t.y +
            (i.col1.y * this.m_localPosition.x +
              i.col2.y * this.m_localPosition.y),
          a = Math.min(e, this.m_position.x),
          l = Math.min(s, this.m_position.y),
          r = Math.max(e, this.m_position.x),
          m = Math.max(s, this.m_position.y),
          _ = new b2AABB();
        _.minVertex.Set(a - this.m_radius, l - this.m_radius),
          _.maxVertex.Set(r + this.m_radius, m + this.m_radius);
        var h = this.m_body.m_world.m_broadPhase;
        h.InRange(_) ? h.MoveProxy(this.m_proxyId, _) : this.m_body.Freeze();
      }
    },
    QuickSync: function (t, i) {
      this.m_R.SetM(i),
        (this.m_position.x =
          i.col1.x * this.m_localPosition.x +
          i.col2.x * this.m_localPosition.y +
          t.x),
        (this.m_position.y =
          i.col1.y * this.m_localPosition.x +
          i.col2.y * this.m_localPosition.y +
          t.y);
    },
    ResetProxy: function (t) {
      if (this.m_proxyId != b2Pair.b2_nullProxy) {
        var i = t.GetProxy(this.m_proxyId);
        t.DestroyProxy(this.m_proxyId), (i = null);
        var o = new b2AABB();
        o.minVertex.Set(
          this.m_position.x - this.m_radius,
          this.m_position.y - this.m_radius
        ),
          o.maxVertex.Set(
            this.m_position.x + this.m_radius,
            this.m_position.y + this.m_radius
          ),
          t.InRange(o)
            ? (this.m_proxyId = t.CreateProxy(o, this))
            : (this.m_proxyId = b2Pair.b2_nullProxy),
          this.m_proxyId == b2Pair.b2_nullProxy && this.m_body.Freeze();
      }
    },
    Support: function (t, i, o) {
      var n = Math.sqrt(t * t + i * i);
      (t /= n),
        (i /= n),
        o.Set(
          this.m_position.x + this.m_radius * t,
          this.m_position.y + this.m_radius * i
        );
    },
    m_localPosition: new b2Vec2(),
    m_radius: null,
  });
var b2MassData = new b2Root();
jQuery.extend(b2MassData.prototype, {
  mass: 0,
  center: new b2Vec2(0, 0),
  I: 0,
  initialize: function () {
    this.center = new b2Vec2(0, 0);
  },
});
var b2PolyDef = new b2Root();
jQuery.extend(b2PolyDef.prototype, b2ShapeDef.prototype),
  jQuery.extend(b2PolyDef.prototype, {
    initialize: function () {
      (this.type = b2Shape.e_unknownShape),
        (this.userData = null),
        (this.localPosition = new b2Vec2(0, 0)),
        (this.localRotation = 0),
        (this.friction = 0.2),
        (this.restitution = 0),
        (this.density = 0),
        (this.categoryBits = 1),
        (this.maskBits = 65535),
        (this.groupIndex = 0),
        (this.vertices = new Array(b2Settings.b2_maxPolyVertices)),
        (this.type = b2Shape.e_polyShape),
        (this.vertexCount = 0);
      for (var t = 0; t < b2Settings.b2_maxPolyVertices; t++)
        this.vertices[t] = new b2Vec2();
    },
    vertices: new Array(b2Settings.b2_maxPolyVertices),
    vertexCount: 0,
  });
var b2AABB = new b2Root();
jQuery.extend(b2AABB.prototype, {
  IsValid: function () {
    var t = this.maxVertex.x,
      i = this.maxVertex.y;
    (t = this.maxVertex.x),
      (i = this.maxVertex.y),
      (t -= this.minVertex.x),
      (i -= this.minVertex.y);
    var o = t >= 0 && i >= 0;
    return (o = o && this.minVertex.IsValid() && this.maxVertex.IsValid());
  },
  minVertex: new b2Vec2(),
  maxVertex: new b2Vec2(),
  initialize: function () {
    (this.minVertex = new b2Vec2()), (this.maxVertex = new b2Vec2());
  },
});
var b2OBB = new b2Root();
jQuery.extend(b2OBB.prototype, {
  R: new b2Mat22(),
  center: new b2Vec2(),
  extents: new b2Vec2(),
  initialize: function () {
    (this.R = new b2Mat22()),
      (this.center = new b2Vec2()),
      (this.extents = new b2Vec2());
  },
});
var b2PolyShape = new b2Root();
jQuery.extend(b2PolyShape.prototype, b2Shape.prototype),
  jQuery.extend(b2PolyShape.prototype, {
    TestPoint: function (t) {
      var i = new b2Vec2();
      i.SetV(t), i.Subtract(this.m_position), i.MulTM(this.m_R);
      for (var o = 0; o < this.m_vertexCount; ++o) {
        var n = new b2Vec2();
        n.SetV(i), n.Subtract(this.m_vertices[o]);
        var e = b2Math.b2Dot(this.m_normals[o], n);
        if (e > 0) return !1;
      }
      return !0;
    },
    initialize: function (t, i, o) {
      (this.m_R = new b2Mat22()),
        (this.m_position = new b2Vec2()),
        (this.m_userData = t.userData),
        (this.m_friction = t.friction),
        (this.m_restitution = t.restitution),
        (this.m_body = i),
        (this.m_proxyId = b2Pair.b2_nullProxy),
        (this.m_maxRadius = 0),
        (this.m_categoryBits = t.categoryBits),
        (this.m_maskBits = t.maskBits),
        (this.m_groupIndex = t.groupIndex),
        (this.syncAABB = new b2AABB()),
        (this.syncMat = new b2Mat22()),
        (this.m_localCentroid = new b2Vec2()),
        (this.m_localOBB = new b2OBB());
      var n,
        e,
        s,
        a = 0,
        l = new b2AABB();
      (this.m_vertices = new Array(b2Settings.b2_maxPolyVertices)),
        (this.m_coreVertices = new Array(b2Settings.b2_maxPolyVertices)),
        (this.m_normals = new Array(b2Settings.b2_maxPolyVertices)),
        (this.m_type = b2Shape.e_polyShape);
      var r = new b2Mat22(t.localRotation);
      if (t.type == b2Shape.e_boxShape) {
        (this.m_localCentroid.x = t.localPosition.x - o.x),
          (this.m_localCentroid.y = t.localPosition.y - o.y);
        var m = t;
        (this.m_vertexCount = 4), (n = m.extents.x), (e = m.extents.y);
        var _ = Math.max(0, n - 2 * b2Settings.b2_linearSlop),
          h = Math.max(0, e - 2 * b2Settings.b2_linearSlop);
        (s = this.m_vertices[0] = new b2Vec2()),
          (s.x = r.col1.x * n + r.col2.x * e),
          (s.y = r.col1.y * n + r.col2.y * e),
          (s = this.m_vertices[1] = new b2Vec2()),
          (s.x = r.col1.x * -n + r.col2.x * e),
          (s.y = r.col1.y * -n + r.col2.y * e),
          (s = this.m_vertices[2] = new b2Vec2()),
          (s.x = r.col1.x * -n + r.col2.x * -e),
          (s.y = r.col1.y * -n + r.col2.y * -e),
          (s = this.m_vertices[3] = new b2Vec2()),
          (s.x = r.col1.x * n + r.col2.x * -e),
          (s.y = r.col1.y * n + r.col2.y * -e),
          (s = this.m_coreVertices[0] = new b2Vec2()),
          (s.x = r.col1.x * _ + r.col2.x * h),
          (s.y = r.col1.y * _ + r.col2.y * h),
          (s = this.m_coreVertices[1] = new b2Vec2()),
          (s.x = r.col1.x * -_ + r.col2.x * h),
          (s.y = r.col1.y * -_ + r.col2.y * h),
          (s = this.m_coreVertices[2] = new b2Vec2()),
          (s.x = r.col1.x * -_ + r.col2.x * -h),
          (s.y = r.col1.y * -_ + r.col2.y * -h),
          (s = this.m_coreVertices[3] = new b2Vec2()),
          (s.x = r.col1.x * _ + r.col2.x * -h),
          (s.y = r.col1.y * _ + r.col2.y * -h);
      } else {
        var c = t;
        (this.m_vertexCount = c.vertexCount),
          b2Shape.PolyCentroid(c.vertices, c.vertexCount, b2PolyShape.tempVec);
        var u = b2PolyShape.tempVec.x,
          y = b2PolyShape.tempVec.y;
        for (
          this.m_localCentroid.x =
            t.localPosition.x + (r.col1.x * u + r.col2.x * y) - o.x,
            this.m_localCentroid.y =
              t.localPosition.y + (r.col1.y * u + r.col2.y * y) - o.y,
            a = 0;
          a < this.m_vertexCount;
          ++a
        ) {
          (this.m_vertices[a] = new b2Vec2()),
            (this.m_coreVertices[a] = new b2Vec2()),
            (n = c.vertices[a].x - u),
            (e = c.vertices[a].y - y),
            (this.m_vertices[a].x = r.col1.x * n + r.col2.x * e),
            (this.m_vertices[a].y = r.col1.y * n + r.col2.y * e);
          var b = this.m_vertices[a].x,
            p = this.m_vertices[a].y,
            x = Math.sqrt(b * b + p * p);
          x > Number.MIN_VALUE && ((b *= 1 / x), (p *= 1 / x)),
            (this.m_coreVertices[a].x =
              this.m_vertices[a].x - 2 * b2Settings.b2_linearSlop * b),
            (this.m_coreVertices[a].y =
              this.m_vertices[a].y - 2 * b2Settings.b2_linearSlop * p);
        }
      }
      var d = Number.MAX_VALUE,
        v = Number.MAX_VALUE,
        f = -Number.MAX_VALUE,
        g = -Number.MAX_VALUE;
      for (this.m_maxRadius = 0, a = 0; a < this.m_vertexCount; ++a) {
        var M = this.m_vertices[a];
        (d = Math.min(d, M.x)),
          (v = Math.min(v, M.y)),
          (f = Math.max(f, M.x)),
          (g = Math.max(g, M.y)),
          (this.m_maxRadius = Math.max(this.m_maxRadius, M.Length()));
      }
      this.m_localOBB.R.SetIdentity(),
        this.m_localOBB.center.Set(0.5 * (d + f), 0.5 * (v + g)),
        this.m_localOBB.extents.Set(0.5 * (f - d), 0.5 * (g - v));
      var V = 0,
        S = 0;
      for (a = 0; a < this.m_vertexCount; ++a)
        (this.m_normals[a] = new b2Vec2()),
          (V = a),
          (S = a + 1 < this.m_vertexCount ? a + 1 : 0),
          (this.m_normals[a].x = this.m_vertices[S].y - this.m_vertices[V].y),
          (this.m_normals[a].y = -(
            this.m_vertices[S].x - this.m_vertices[V].x
          )),
          this.m_normals[a].Normalize();
      for (a = 0; a < this.m_vertexCount; ++a)
        (V = a), (S = a + 1 < this.m_vertexCount ? a + 1 : 0);
      this.m_R.SetM(this.m_body.m_R),
        (this.m_position.x =
          this.m_body.m_position.x +
          (this.m_R.col1.x * this.m_localCentroid.x +
            this.m_R.col2.x * this.m_localCentroid.y)),
        (this.m_position.y =
          this.m_body.m_position.y +
          (this.m_R.col1.y * this.m_localCentroid.x +
            this.m_R.col2.y * this.m_localCentroid.y)),
        (b2PolyShape.tAbsR.col1.x =
          this.m_R.col1.x * this.m_localOBB.R.col1.x +
          this.m_R.col2.x * this.m_localOBB.R.col1.y),
        (b2PolyShape.tAbsR.col1.y =
          this.m_R.col1.y * this.m_localOBB.R.col1.x +
          this.m_R.col2.y * this.m_localOBB.R.col1.y),
        (b2PolyShape.tAbsR.col2.x =
          this.m_R.col1.x * this.m_localOBB.R.col2.x +
          this.m_R.col2.x * this.m_localOBB.R.col2.y),
        (b2PolyShape.tAbsR.col2.y =
          this.m_R.col1.y * this.m_localOBB.R.col2.x +
          this.m_R.col2.y * this.m_localOBB.R.col2.y),
        b2PolyShape.tAbsR.Abs(),
        (n =
          b2PolyShape.tAbsR.col1.x * this.m_localOBB.extents.x +
          b2PolyShape.tAbsR.col2.x * this.m_localOBB.extents.y),
        (e =
          b2PolyShape.tAbsR.col1.y * this.m_localOBB.extents.x +
          b2PolyShape.tAbsR.col2.y * this.m_localOBB.extents.y);
      var C =
          this.m_position.x +
          (this.m_R.col1.x * this.m_localOBB.center.x +
            this.m_R.col2.x * this.m_localOBB.center.y),
        A =
          this.m_position.y +
          (this.m_R.col1.y * this.m_localOBB.center.x +
            this.m_R.col2.y * this.m_localOBB.center.y);
      (l.minVertex.x = C - n),
        (l.minVertex.y = A - e),
        (l.maxVertex.x = C + n),
        (l.maxVertex.y = A + e);
      var w = this.m_body.m_world.m_broadPhase;
      w.InRange(l)
        ? (this.m_proxyId = w.CreateProxy(l, this))
        : (this.m_proxyId = b2Pair.b2_nullProxy),
        this.m_proxyId == b2Pair.b2_nullProxy && this.m_body.Freeze();
    },
    syncAABB: new b2AABB(),
    syncMat: new b2Mat22(),
    Synchronize: function (t, i, o, n) {
      if (
        (this.m_R.SetM(n),
        (this.m_position.x =
          this.m_body.m_position.x +
          (n.col1.x * this.m_localCentroid.x +
            n.col2.x * this.m_localCentroid.y)),
        (this.m_position.y =
          this.m_body.m_position.y +
          (n.col1.y * this.m_localCentroid.x +
            n.col2.y * this.m_localCentroid.y)),
        this.m_proxyId != b2Pair.b2_nullProxy)
      ) {
        var e,
          s,
          a = i.col1,
          l = i.col2,
          r = this.m_localOBB.R.col1,
          m = this.m_localOBB.R.col2;
        (this.syncMat.col1.x = a.x * r.x + l.x * r.y),
          (this.syncMat.col1.y = a.y * r.x + l.y * r.y),
          (this.syncMat.col2.x = a.x * m.x + l.x * m.y),
          (this.syncMat.col2.y = a.y * m.x + l.y * m.y),
          this.syncMat.Abs(),
          (e = this.m_localCentroid.x + this.m_localOBB.center.x),
          (s = this.m_localCentroid.y + this.m_localOBB.center.y);
        var _ = t.x + (i.col1.x * e + i.col2.x * s),
          h = t.y + (i.col1.y * e + i.col2.y * s);
        (e =
          this.syncMat.col1.x * this.m_localOBB.extents.x +
          this.syncMat.col2.x * this.m_localOBB.extents.y),
          (s =
            this.syncMat.col1.y * this.m_localOBB.extents.x +
            this.syncMat.col2.y * this.m_localOBB.extents.y),
          (this.syncAABB.minVertex.x = _ - e),
          (this.syncAABB.minVertex.y = h - s),
          (this.syncAABB.maxVertex.x = _ + e),
          (this.syncAABB.maxVertex.y = h + s),
          (a = n.col1),
          (l = n.col2),
          (r = this.m_localOBB.R.col1),
          (m = this.m_localOBB.R.col2),
          (this.syncMat.col1.x = a.x * r.x + l.x * r.y),
          (this.syncMat.col1.y = a.y * r.x + l.y * r.y),
          (this.syncMat.col2.x = a.x * m.x + l.x * m.y),
          (this.syncMat.col2.y = a.y * m.x + l.y * m.y),
          this.syncMat.Abs(),
          (e = this.m_localCentroid.x + this.m_localOBB.center.x),
          (s = this.m_localCentroid.y + this.m_localOBB.center.y),
          (_ = o.x + (n.col1.x * e + n.col2.x * s)),
          (h = o.y + (n.col1.y * e + n.col2.y * s)),
          (e =
            this.syncMat.col1.x * this.m_localOBB.extents.x +
            this.syncMat.col2.x * this.m_localOBB.extents.y),
          (s =
            this.syncMat.col1.y * this.m_localOBB.extents.x +
            this.syncMat.col2.y * this.m_localOBB.extents.y),
          (this.syncAABB.minVertex.x = Math.min(
            this.syncAABB.minVertex.x,
            _ - e
          )),
          (this.syncAABB.minVertex.y = Math.min(
            this.syncAABB.minVertex.y,
            h - s
          )),
          (this.syncAABB.maxVertex.x = Math.max(
            this.syncAABB.maxVertex.x,
            _ + e
          )),
          (this.syncAABB.maxVertex.y = Math.max(
            this.syncAABB.maxVertex.y,
            h + s
          ));
        var c = this.m_body.m_world.m_broadPhase;
        c.InRange(this.syncAABB)
          ? c.MoveProxy(this.m_proxyId, this.syncAABB)
          : this.m_body.Freeze();
      }
    },
    QuickSync: function (t, i) {
      this.m_R.SetM(i),
        (this.m_position.x =
          t.x +
          (i.col1.x * this.m_localCentroid.x +
            i.col2.x * this.m_localCentroid.y)),
        (this.m_position.y =
          t.y +
          (i.col1.y * this.m_localCentroid.x +
            i.col2.y * this.m_localCentroid.y));
    },
    ResetProxy: function (t) {
      if (this.m_proxyId != b2Pair.b2_nullProxy) {
        var i = t.GetProxy(this.m_proxyId);
        t.DestroyProxy(this.m_proxyId), (i = null);
        var o = b2Math.b2MulMM(this.m_R, this.m_localOBB.R),
          n = b2Math.b2AbsM(o),
          e = b2Math.b2MulMV(n, this.m_localOBB.extents),
          s = b2Math.b2MulMV(this.m_R, this.m_localOBB.center);
        s.Add(this.m_position);
        var a = new b2AABB();
        a.minVertex.SetV(s),
          a.minVertex.Subtract(e),
          a.maxVertex.SetV(s),
          a.maxVertex.Add(e),
          t.InRange(a)
            ? (this.m_proxyId = t.CreateProxy(a, this))
            : (this.m_proxyId = b2Pair.b2_nullProxy),
          this.m_proxyId == b2Pair.b2_nullProxy && this.m_body.Freeze();
      }
    },
    Support: function (t, i, o) {
      for (
        var n = t * this.m_R.col1.x + i * this.m_R.col1.y,
          e = t * this.m_R.col2.x + i * this.m_R.col2.y,
          s = 0,
          a = this.m_coreVertices[0].x * n + this.m_coreVertices[0].y * e,
          l = 1;
        l < this.m_vertexCount;
        ++l
      ) {
        var r = this.m_coreVertices[l].x * n + this.m_coreVertices[l].y * e;
        r > a && ((s = l), (a = r));
      }
      o.Set(
        this.m_position.x +
          (this.m_R.col1.x * this.m_coreVertices[s].x +
            this.m_R.col2.x * this.m_coreVertices[s].y),
        this.m_position.y +
          (this.m_R.col1.y * this.m_coreVertices[s].x +
            this.m_R.col2.y * this.m_coreVertices[s].y)
      );
    },
    m_localCentroid: new b2Vec2(),
    m_localOBB: new b2OBB(),
    m_vertices: null,
    m_coreVertices: null,
    m_vertexCount: 0,
    m_normals: null,
  }),
  (b2PolyShape.tempVec = new b2Vec2()),
  (b2PolyShape.tAbsR = new b2Mat22());
var b2Bound = new b2Root();
jQuery.extend(b2Bound.prototype, {
  IsLower: function () {
    return 0 == (1 & this.value);
  },
  IsUpper: function () {
    return 1 == (1 & this.value);
  },
  Swap: function (t) {
    var i = this.value,
      o = this.proxyId,
      n = this.stabbingCount;
    (this.value = t.value),
      (this.proxyId = t.proxyId),
      (this.stabbingCount = t.stabbingCount),
      (t.value = i),
      (t.proxyId = o),
      (t.stabbingCount = n);
  },
  value: 0,
  proxyId: 0,
  stabbingCount: 0,
  initialize: function () {},
});
var b2BoundValues = new b2Root();
jQuery.extend(b2BoundValues.prototype, {
  lowerValues: [0, 0],
  upperValues: [0, 0],
  initialize: function () {
    (this.lowerValues = [0, 0]), (this.upperValues = [0, 0]);
  },
});
var b2BufferedPair = new b2Root();
jQuery.extend(b2BufferedPair.prototype, {
  proxyId1: 0,
  proxyId2: 0,
  initialize: function () {},
});
var b2Pair = new b2Root();
jQuery.extend(b2Pair.prototype, {
  SetBuffered: function () {
    this.status |= b2Pair.e_pairBuffered;
  },
  ClearBuffered: function () {
    this.status &= ~b2Pair.e_pairBuffered;
  },
  IsBuffered: function () {
    return (this.status & b2Pair.e_pairBuffered) == b2Pair.e_pairBuffered;
  },
  SetRemoved: function () {
    this.status |= b2Pair.e_pairRemoved;
  },
  ClearRemoved: function () {
    this.status &= ~b2Pair.e_pairRemoved;
  },
  IsRemoved: function () {
    return (this.status & b2Pair.e_pairRemoved) == b2Pair.e_pairRemoved;
  },
  SetFinal: function () {
    this.status |= b2Pair.e_pairFinal;
  },
  IsFinal: function () {
    return (this.status & b2Pair.e_pairFinal) == b2Pair.e_pairFinal;
  },
  userData: null,
  proxyId1: 0,
  proxyId2: 0,
  next: 0,
  status: 0,
  initialize: function () {},
}),
  (b2Pair.b2_nullPair = b2Settings.USHRT_MAX),
  (b2Pair.b2_nullProxy = b2Settings.USHRT_MAX),
  (b2Pair.b2_tableCapacity = b2Settings.b2_maxPairs),
  (b2Pair.b2_tableMask = b2Pair.b2_tableCapacity - 1),
  (b2Pair.e_pairBuffered = 1),
  (b2Pair.e_pairRemoved = 2),
  (b2Pair.e_pairFinal = 4);
var b2PairCallback = new b2Root();
jQuery.extend(b2PairCallback.prototype, {
  PairAdded: function (t, i) {
    return null;
  },
  PairRemoved: function (t, i, o) {},
  initialize: function () {},
});
var b2PairManager = new b2Root();
jQuery.extend(b2PairManager.prototype, {
  initialize: function () {
    var t = 0;
    for (
      this.m_hashTable = new Array(b2Pair.b2_tableCapacity), t = 0;
      t < b2Pair.b2_tableCapacity;
      ++t
    )
      this.m_hashTable[t] = b2Pair.b2_nullPair;
    for (
      this.m_pairs = new Array(b2Settings.b2_maxPairs), t = 0;
      t < b2Settings.b2_maxPairs;
      ++t
    )
      this.m_pairs[t] = new b2Pair();
    for (
      this.m_pairBuffer = new Array(b2Settings.b2_maxPairs), t = 0;
      t < b2Settings.b2_maxPairs;
      ++t
    )
      this.m_pairBuffer[t] = new b2BufferedPair();
    for (t = 0; t < b2Settings.b2_maxPairs; ++t)
      (this.m_pairs[t].proxyId1 = b2Pair.b2_nullProxy),
        (this.m_pairs[t].proxyId2 = b2Pair.b2_nullProxy),
        (this.m_pairs[t].userData = null),
        (this.m_pairs[t].status = 0),
        (this.m_pairs[t].next = t + 1);
    (this.m_pairs[b2Settings.b2_maxPairs - 1].next = b2Pair.b2_nullPair),
      (this.m_pairCount = 0);
  },
  Initialize: function (t, i) {
    (this.m_broadPhase = t), (this.m_callback = i);
  },
  AddBufferedPair: function (t, i) {
    var o = this.AddPair(t, i);
    0 == o.IsBuffered() &&
      (o.SetBuffered(),
      (this.m_pairBuffer[this.m_pairBufferCount].proxyId1 = o.proxyId1),
      (this.m_pairBuffer[this.m_pairBufferCount].proxyId2 = o.proxyId2),
      ++this.m_pairBufferCount),
      o.ClearRemoved(),
      b2BroadPhase.s_validate && this.ValidateBuffer();
  },
  RemoveBufferedPair: function (t, i) {
    var o = this.Find(t, i);
    null != o &&
      (0 == o.IsBuffered() &&
        (o.SetBuffered(),
        (this.m_pairBuffer[this.m_pairBufferCount].proxyId1 = o.proxyId1),
        (this.m_pairBuffer[this.m_pairBufferCount].proxyId2 = o.proxyId2),
        ++this.m_pairBufferCount),
      o.SetRemoved(),
      b2BroadPhase.s_validate && this.ValidateBuffer());
  },
  Commit: function () {
    var t = 0,
      i = 0,
      o = this.m_broadPhase.m_proxyPool;
    for (t = 0; t < this.m_pairBufferCount; ++t) {
      var n = this.Find(
        this.m_pairBuffer[t].proxyId1,
        this.m_pairBuffer[t].proxyId2
      );
      n.ClearBuffered();
      var e = o[n.proxyId1],
        s = o[n.proxyId2];
      n.IsRemoved()
        ? (1 == n.IsFinal() &&
            this.m_callback.PairRemoved(e.userData, s.userData, n.userData),
          (this.m_pairBuffer[i].proxyId1 = n.proxyId1),
          (this.m_pairBuffer[i].proxyId2 = n.proxyId2),
          ++i)
        : 0 == n.IsFinal() &&
          ((n.userData = this.m_callback.PairAdded(e.userData, s.userData)),
          n.SetFinal());
    }
    for (t = 0; i > t; ++t)
      this.RemovePair(
        this.m_pairBuffer[t].proxyId1,
        this.m_pairBuffer[t].proxyId2
      );
    (this.m_pairBufferCount = 0),
      b2BroadPhase.s_validate && this.ValidateTable();
  },
  AddPair: function (t, i) {
    if (t > i) {
      var o = t;
      (t = i), (i = o);
    }
    var n = b2PairManager.Hash(t, i) & b2Pair.b2_tableMask,
      e = (e = this.FindHash(t, i, n));
    if (null != e) return e;
    var s = this.m_freePair;
    return (
      (e = this.m_pairs[s]),
      (this.m_freePair = e.next),
      (e.proxyId1 = t),
      (e.proxyId2 = i),
      (e.status = 0),
      (e.userData = null),
      (e.next = this.m_hashTable[n]),
      (this.m_hashTable[n] = s),
      ++this.m_pairCount,
      e
    );
  },
  RemovePair: function (t, i) {
    if (t > i) {
      var o = t;
      (t = i), (i = o);
    }
    for (
      var n = b2PairManager.Hash(t, i) & b2Pair.b2_tableMask,
        e = this.m_hashTable[n],
        s = null;
      e != b2Pair.b2_nullPair;

    ) {
      if (b2PairManager.Equals(this.m_pairs[e], t, i)) {
        var a = e;
        s
          ? (s.next = this.m_pairs[e].next)
          : (this.m_hashTable[n] = this.m_pairs[e].next);
        var l = this.m_pairs[a],
          r = l.userData;
        return (
          (l.next = this.m_freePair),
          (l.proxyId1 = b2Pair.b2_nullProxy),
          (l.proxyId2 = b2Pair.b2_nullProxy),
          (l.userData = null),
          (l.status = 0),
          (this.m_freePair = a),
          --this.m_pairCount,
          r
        );
      }
      (s = this.m_pairs[e]), (e = s.next);
    }
    return null;
  },
  Find: function (t, i) {
    if (t > i) {
      var o = t;
      (t = i), (i = o);
    }
    var n = b2PairManager.Hash(t, i) & b2Pair.b2_tableMask;
    return this.FindHash(t, i, n);
  },
  FindHash: function (t, i, o) {
    for (
      var n = this.m_hashTable[o];
      n != b2Pair.b2_nullPair &&
      0 == b2PairManager.Equals(this.m_pairs[n], t, i);

    )
      n = this.m_pairs[n].next;
    return n == b2Pair.b2_nullPair ? null : this.m_pairs[n];
  },
  ValidateBuffer: function () {},
  ValidateTable: function () {},
  m_broadPhase: null,
  m_callback: null,
  m_pairs: null,
  m_freePair: 0,
  m_pairCount: 0,
  m_pairBuffer: null,
  m_pairBufferCount: 0,
  m_hashTable: null,
}),
  (b2PairManager.Hash = function (t, i) {
    var o = ((i << 16) & 4294901760) | t;
    return (
      (o = ~o + ((o << 15) & 4294934528)),
      (o ^= (o >> 12) & 1048575),
      (o += (o << 2) & 4294967292),
      (o ^= (o >> 4) & 268435455),
      (o = 2057 * o),
      (o ^= (o >> 16) & 65535)
    );
  }),
  (b2PairManager.Equals = function (t, i, o) {
    return t.proxyId1 == i && t.proxyId2 == o;
  }),
  (b2PairManager.EqualsPair = function (t, i) {
    return t.proxyId1 == i.proxyId1 && t.proxyId2 == i.proxyId2;
  });
var b2BroadPhase = new b2Root();
jQuery.extend(b2BroadPhase.prototype, {
  initialize: function (t, i) {
    (this.m_pairManager = new b2PairManager()),
      (this.m_proxyPool = new Array(b2Settings.b2_maxPairs)),
      (this.m_bounds = new Array(2 * b2Settings.b2_maxProxies)),
      (this.m_queryResults = new Array(b2Settings.b2_maxProxies)),
      (this.m_quantizationFactor = new b2Vec2());
    var o = 0;
    for (
      this.m_pairManager.Initialize(this, i),
        this.m_worldAABB = t,
        this.m_proxyCount = 0,
        o = 0;
      o < b2Settings.b2_maxProxies;
      o++
    )
      this.m_queryResults[o] = 0;
    for (this.m_bounds = new Array(2), o = 0; 2 > o; o++) {
      this.m_bounds[o] = new Array(2 * b2Settings.b2_maxProxies);
      for (var n = 0; n < 2 * b2Settings.b2_maxProxies; n++)
        this.m_bounds[o][n] = new b2Bound();
    }
    var e = t.maxVertex.x,
      s = t.maxVertex.y;
    (e -= t.minVertex.x),
      (s -= t.minVertex.y),
      (this.m_quantizationFactor.x = b2Settings.USHRT_MAX / e),
      (this.m_quantizationFactor.y = b2Settings.USHRT_MAX / s);
    var a;
    for (o = 0; o < b2Settings.b2_maxProxies - 1; ++o)
      (a = new b2Proxy()),
        (this.m_proxyPool[o] = a),
        a.SetNext(o + 1),
        (a.timeStamp = 0),
        (a.overlapCount = b2BroadPhase.b2_invalid),
        (a.userData = null);
    (a = new b2Proxy()),
      (this.m_proxyPool[b2Settings.b2_maxProxies - 1] = a),
      a.SetNext(b2Pair.b2_nullProxy),
      (a.timeStamp = 0),
      (a.overlapCount = b2BroadPhase.b2_invalid),
      (a.userData = null),
      (this.m_freeProxy = 0),
      (this.m_timeStamp = 1),
      (this.m_queryResultCount = 0);
  },
  InRange: function (t) {
    var i, o, n, e;
    return (
      (i = t.minVertex.x),
      (o = t.minVertex.y),
      (i -= this.m_worldAABB.maxVertex.x),
      (o -= this.m_worldAABB.maxVertex.y),
      (n = this.m_worldAABB.minVertex.x),
      (e = this.m_worldAABB.minVertex.y),
      (n -= t.maxVertex.x),
      (e -= t.maxVertex.y),
      (i = b2Math.b2Max(i, n)),
      (o = b2Math.b2Max(o, e)),
      b2Math.b2Max(i, o) < 0
    );
  },
  GetProxy: function (t) {
    return t == b2Pair.b2_nullProxy || 0 == this.m_proxyPool[t].IsValid()
      ? null
      : this.m_proxyPool[t];
  },
  CreateProxy: function (t, i) {
    var o,
      n = 0,
      e = this.m_freeProxy;
    (o = this.m_proxyPool[e]),
      (this.m_freeProxy = o.GetNext()),
      (o.overlapCount = 0),
      (o.userData = i);
    var s = 2 * this.m_proxyCount,
      a = new Array(),
      l = new Array();
    this.ComputeBounds(a, l, t);
    for (var r = 0; 2 > r; ++r) {
      var m = this.m_bounds[r],
        _ = 0,
        h = 0,
        c = [_],
        u = [h];
      this.Query(c, u, a[r], l[r], m, s, r), (_ = c[0]), (h = u[0]);
      var y,
        b,
        p = new Array(),
        x = 0,
        d = s - h;
      for (x = 0; d > x; x++)
        (p[x] = new b2Bound()),
          (y = p[x]),
          (b = m[h + x]),
          (y.value = b.value),
          (y.proxyId = b.proxyId),
          (y.stabbingCount = b.stabbingCount);
      d = p.length;
      var v = h + 2;
      for (x = 0; d > x; x++)
        (b = p[x]),
          (y = m[v + x]),
          (y.value = b.value),
          (y.proxyId = b.proxyId),
          (y.stabbingCount = b.stabbingCount);
      for (p = new Array(), d = h - _, x = 0; d > x; x++)
        (p[x] = new b2Bound()),
          (y = p[x]),
          (b = m[_ + x]),
          (y.value = b.value),
          (y.proxyId = b.proxyId),
          (y.stabbingCount = b.stabbingCount);
      for (d = p.length, v = _ + 1, x = 0; d > x; x++)
        (b = p[x]),
          (y = m[v + x]),
          (y.value = b.value),
          (y.proxyId = b.proxyId),
          (y.stabbingCount = b.stabbingCount);
      for (
        ++h,
          m[_].value = a[r],
          m[_].proxyId = e,
          m[h].value = l[r],
          m[h].proxyId = e,
          m[_].stabbingCount = 0 == _ ? 0 : m[_ - 1].stabbingCount,
          m[h].stabbingCount = m[h - 1].stabbingCount,
          n = _;
        h > n;
        ++n
      )
        m[n].stabbingCount++;
      for (n = _; s + 2 > n; ++n) {
        var f = this.m_proxyPool[m[n].proxyId];
        m[n].IsLower() ? (f.lowerBounds[r] = n) : (f.upperBounds[r] = n);
      }
    }
    ++this.m_proxyCount;
    for (var g = 0; g < this.m_queryResultCount; ++g)
      this.m_pairManager.AddBufferedPair(e, this.m_queryResults[g]);
    return (
      this.m_pairManager.Commit(),
      (this.m_queryResultCount = 0),
      this.IncrementTimeStamp(),
      e
    );
  },
  DestroyProxy: function (t) {
    for (
      var i = this.m_proxyPool[t], o = 2 * this.m_proxyCount, n = 0;
      2 > n;
      ++n
    ) {
      var e,
        s,
        a = this.m_bounds[n],
        l = i.lowerBounds[n],
        r = i.upperBounds[n],
        m = a[l].value,
        _ = a[r].value,
        h = new Array(),
        c = 0,
        u = r - l - 1;
      for (c = 0; u > c; c++)
        (h[c] = new b2Bound()),
          (e = h[c]),
          (s = a[l + 1 + c]),
          (e.value = s.value),
          (e.proxyId = s.proxyId),
          (e.stabbingCount = s.stabbingCount);
      u = h.length;
      var y = l;
      for (c = 0; u > c; c++)
        (s = h[c]),
          (e = a[y + c]),
          (e.value = s.value),
          (e.proxyId = s.proxyId),
          (e.stabbingCount = s.stabbingCount);
      for (h = new Array(), u = o - r - 1, c = 0; u > c; c++)
        (h[c] = new b2Bound()),
          (e = h[c]),
          (s = a[r + 1 + c]),
          (e.value = s.value),
          (e.proxyId = s.proxyId),
          (e.stabbingCount = s.stabbingCount);
      for (u = h.length, y = r - 1, c = 0; u > c; c++)
        (s = h[c]),
          (e = a[y + c]),
          (e.value = s.value),
          (e.proxyId = s.proxyId),
          (e.stabbingCount = s.stabbingCount);
      u = o - 2;
      for (var b = l; u > b; ++b) {
        var p = this.m_proxyPool[a[b].proxyId];
        a[b].IsLower() ? (p.lowerBounds[n] = b) : (p.upperBounds[n] = b);
      }
      u = r - 1;
      for (var x = l; u > x; ++x) a[x].stabbingCount--;
      this.Query([0], [0], m, _, a, o - 2, n);
    }
    for (var d = 0; d < this.m_queryResultCount; ++d)
      this.m_pairManager.RemoveBufferedPair(t, this.m_queryResults[d]);
    this.m_pairManager.Commit(),
      (this.m_queryResultCount = 0),
      this.IncrementTimeStamp(),
      (i.userData = null),
      (i.overlapCount = b2BroadPhase.b2_invalid),
      (i.lowerBounds[0] = b2BroadPhase.b2_invalid),
      (i.lowerBounds[1] = b2BroadPhase.b2_invalid),
      (i.upperBounds[0] = b2BroadPhase.b2_invalid),
      (i.upperBounds[1] = b2BroadPhase.b2_invalid),
      i.SetNext(this.m_freeProxy),
      (this.m_freeProxy = t),
      --this.m_proxyCount;
  },
  MoveProxy: function (t, i) {
    var o,
      n,
      e,
      s,
      a = 0,
      l = 0,
      r = 0;
    if (
      !(t == b2Pair.b2_nullProxy || b2Settings.b2_maxProxies <= t) &&
      0 != i.IsValid()
    ) {
      var m = 2 * this.m_proxyCount,
        _ = this.m_proxyPool[t],
        h = new b2BoundValues();
      this.ComputeBounds(h.lowerValues, h.upperValues, i);
      var c = new b2BoundValues();
      for (a = 0; 2 > a; ++a)
        (c.lowerValues[a] = this.m_bounds[a][_.lowerBounds[a]].value),
          (c.upperValues[a] = this.m_bounds[a][_.upperBounds[a]].value);
      for (a = 0; 2 > a; ++a) {
        var u = this.m_bounds[a],
          y = _.lowerBounds[a],
          b = _.upperBounds[a],
          p = h.lowerValues[a],
          x = h.upperValues[a],
          d = p - u[y].value,
          v = x - u[b].value;
        if (((u[y].value = p), (u[b].value = x), 0 > d))
          for (l = y; l > 0 && p < u[l - 1].value; ) {
            (o = u[l]), (n = u[l - 1]);
            var f = n.proxyId,
              g = this.m_proxyPool[n.proxyId];
            n.stabbingCount++,
              1 == n.IsUpper()
                ? (this.TestOverlap(h, g) &&
                    this.m_pairManager.AddBufferedPair(t, f),
                  g.upperBounds[a]++,
                  o.stabbingCount++)
                : (g.lowerBounds[a]++, o.stabbingCount--),
              _.lowerBounds[a]--,
              o.Swap(n),
              --l;
          }
        if (v > 0)
          for (l = b; m - 1 > l && u[l + 1].value <= x; )
            (o = u[l]),
              (e = u[l + 1]),
              (r = e.proxyId),
              (s = this.m_proxyPool[r]),
              e.stabbingCount++,
              1 == e.IsLower()
                ? (this.TestOverlap(h, s) &&
                    this.m_pairManager.AddBufferedPair(t, r),
                  s.lowerBounds[a]--,
                  o.stabbingCount++)
                : (s.upperBounds[a]--, o.stabbingCount--),
              _.upperBounds[a]++,
              o.Swap(e),
              l++;
        if (d > 0)
          for (l = y; m - 1 > l && u[l + 1].value <= p; )
            (o = u[l]),
              (e = u[l + 1]),
              (r = e.proxyId),
              (s = this.m_proxyPool[r]),
              e.stabbingCount--,
              e.IsUpper()
                ? (this.TestOverlap(c, s) &&
                    this.m_pairManager.RemoveBufferedPair(t, r),
                  s.upperBounds[a]--,
                  o.stabbingCount--)
                : (s.lowerBounds[a]--, o.stabbingCount++),
              _.lowerBounds[a]++,
              o.Swap(e),
              l++;
        if (0 > v)
          for (l = b; l > 0 && x < u[l - 1].value; )
            (o = u[l]),
              (n = u[l - 1]),
              (f = n.proxyId),
              (g = this.m_proxyPool[f]),
              n.stabbingCount--,
              1 == n.IsLower()
                ? (this.TestOverlap(c, g) &&
                    this.m_pairManager.RemoveBufferedPair(t, f),
                  g.lowerBounds[a]++,
                  o.stabbingCount--)
                : (g.upperBounds[a]++, o.stabbingCount++),
              _.upperBounds[a]--,
              o.Swap(n),
              l--;
      }
    }
  },
  Commit: function () {
    this.m_pairManager.Commit();
  },
  QueryAABB: function (t, i, o) {
    var n = new Array(),
      e = new Array();
    this.ComputeBounds(n, e, t);
    var s = 0,
      a = 0,
      l = [s],
      r = [a];
    this.Query(l, r, n[0], e[0], this.m_bounds[0], 2 * this.m_proxyCount, 0),
      this.Query(l, r, n[1], e[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
    for (var m = 0, _ = 0; _ < this.m_queryResultCount && o > m; ++_, ++m) {
      var h = this.m_proxyPool[this.m_queryResults[_]];
      i[_] = h.userData;
    }
    return (this.m_queryResultCount = 0), this.IncrementTimeStamp(), m;
  },
  Validate: function () {
    for (var t = 0; 2 > t; ++t)
      for (
        var i = this.m_bounds[t], o = 2 * this.m_proxyCount, n = 0, e = 0;
        o > e;
        ++e
      ) {
        var s = i[e];
        1 == s.IsLower() ? n++ : n--;
      }
  },
  ComputeBounds: function (t, i, o) {
    var n = o.minVertex.x,
      e = o.minVertex.y;
    (n = b2Math.b2Min(n, this.m_worldAABB.maxVertex.x)),
      (e = b2Math.b2Min(e, this.m_worldAABB.maxVertex.y)),
      (n = b2Math.b2Max(n, this.m_worldAABB.minVertex.x)),
      (e = b2Math.b2Max(e, this.m_worldAABB.minVertex.y));
    var s = o.maxVertex.x,
      a = o.maxVertex.y;
    (s = b2Math.b2Min(s, this.m_worldAABB.maxVertex.x)),
      (a = b2Math.b2Min(a, this.m_worldAABB.maxVertex.y)),
      (s = b2Math.b2Max(s, this.m_worldAABB.minVertex.x)),
      (a = b2Math.b2Max(a, this.m_worldAABB.minVertex.y)),
      (t[0] =
        (this.m_quantizationFactor.x * (n - this.m_worldAABB.minVertex.x)) &
        (b2Settings.USHRT_MAX - 1)),
      (i[0] =
        ((this.m_quantizationFactor.x * (s - this.m_worldAABB.minVertex.x)) &
          65535) |
        1),
      (t[1] =
        (this.m_quantizationFactor.y * (e - this.m_worldAABB.minVertex.y)) &
        (b2Settings.USHRT_MAX - 1)),
      (i[1] =
        ((this.m_quantizationFactor.y * (a - this.m_worldAABB.minVertex.y)) &
          65535) |
        1);
  },
  TestOverlapValidate: function (t, i) {
    for (var o = 0; 2 > o; ++o) {
      var n = this.m_bounds[o];
      if (n[t.lowerBounds[o]].value > n[i.upperBounds[o]].value) return !1;
      if (n[t.upperBounds[o]].value < n[i.lowerBounds[o]].value) return !1;
    }
    return !0;
  },
  TestOverlap: function (t, i) {
    for (var o = 0; 2 > o; ++o) {
      var n = this.m_bounds[o];
      if (t.lowerValues[o] > n[i.upperBounds[o]].value) return !1;
      if (t.upperValues[o] < n[i.lowerBounds[o]].value) return !1;
    }
    return !0;
  },
  Query: function (t, i, o, n, e, s, a) {
    for (
      var l = b2BroadPhase.BinarySearch(e, s, o),
        r = b2BroadPhase.BinarySearch(e, s, n),
        m = l;
      r > m;
      ++m
    )
      e[m].IsLower() && this.IncrementOverlapCount(e[m].proxyId);
    if (l > 0)
      for (var _ = l - 1, h = e[_].stabbingCount; h; ) {
        if (e[_].IsLower()) {
          var c = this.m_proxyPool[e[_].proxyId];
          l <= c.upperBounds[a] &&
            (this.IncrementOverlapCount(e[_].proxyId), --h);
        }
        --_;
      }
    (t[0] = l), (i[0] = r);
  },
  IncrementOverlapCount: function (t) {
    var i = this.m_proxyPool[t];
    i.timeStamp < this.m_timeStamp
      ? ((i.timeStamp = this.m_timeStamp), (i.overlapCount = 1))
      : ((i.overlapCount = 2),
        (this.m_queryResults[this.m_queryResultCount] = t),
        ++this.m_queryResultCount);
  },
  IncrementTimeStamp: function () {
    if (this.m_timeStamp == b2Settings.USHRT_MAX) {
      for (var t = 0; t < b2Settings.b2_maxProxies; ++t)
        this.m_proxyPool[t].timeStamp = 0;
      this.m_timeStamp = 1;
    } else ++this.m_timeStamp;
  },
  m_pairManager: new b2PairManager(),
  m_proxyPool: new Array(b2Settings.b2_maxPairs),
  m_freeProxy: 0,
  m_bounds: new Array(2 * b2Settings.b2_maxProxies),
  m_queryResults: new Array(b2Settings.b2_maxProxies),
  m_queryResultCount: 0,
  m_worldAABB: null,
  m_quantizationFactor: new b2Vec2(),
  m_proxyCount: 0,
  m_timeStamp: 0,
}),
  (b2BroadPhase.s_validate = !1),
  (b2BroadPhase.b2_invalid = b2Settings.USHRT_MAX),
  (b2BroadPhase.b2_nullEdge = b2Settings.USHRT_MAX),
  (b2BroadPhase.BinarySearch = function (t, i, o) {
    for (var n = 0, e = i - 1; e >= n; ) {
      var s = Math.floor((n + e) / 2);
      if (t[s].value > o) e = s - 1;
      else {
        if (!(t[s].value < o)) return s;
        n = s + 1;
      }
    }
    return n;
  });
var b2Collision = new b2Root();
jQuery.extend(b2Collision.prototype, { initialize: function () {} }),
  (b2Collision.b2_nullFeature = 255),
  (b2Collision.ClipSegmentToLine = function (t, i, o, n) {
    var e = 0,
      s = i[0].v,
      a = i[1].v,
      l = b2Math.b2Dot(o, i[0].v) - n,
      r = b2Math.b2Dot(o, i[1].v) - n;
    if ((0 >= l && (t[e++] = i[0]), 0 >= r && (t[e++] = i[1]), 0 > l * r)) {
      var m = l / (l - r),
        _ = t[e].v;
      (_.x = s.x + m * (a.x - s.x)),
        (_.y = s.y + m * (a.y - s.y)),
        l > 0 ? (t[e].id = i[0].id) : (t[e].id = i[1].id),
        ++e;
    }
    return e;
  }),
  (b2Collision.EdgeSeparation = function (t, i, o) {
    var n = t.m_vertices,
      e = o.m_vertexCount,
      s = o.m_vertices,
      a = t.m_normals[i].x,
      l = t.m_normals[i].y,
      r = a,
      m = t.m_R;
    (a = m.col1.x * r + m.col2.x * l), (l = m.col1.y * r + m.col2.y * l);
    var _ = a,
      h = l;
    (m = o.m_R),
      (r = _ * m.col1.x + h * m.col1.y),
      (h = _ * m.col2.x + h * m.col2.y),
      (_ = r);
    for (var c = 0, u = Number.MAX_VALUE, y = 0; e > y; ++y) {
      var b = s[y],
        p = b.x * _ + b.y * h;
      u > p && ((u = p), (c = y));
    }
    m = t.m_R;
    var x = t.m_position.x + (m.col1.x * n[i].x + m.col2.x * n[i].y),
      d = t.m_position.y + (m.col1.y * n[i].x + m.col2.y * n[i].y);
    m = o.m_R;
    var v = o.m_position.x + (m.col1.x * s[c].x + m.col2.x * s[c].y),
      f = o.m_position.y + (m.col1.y * s[c].x + m.col2.y * s[c].y);
    (v -= x), (f -= d);
    var g = v * a + f * l;
    return g;
  }),
  (b2Collision.FindMaxSeparation = function (t, i, o, n) {
    for (
      var e = i.m_vertexCount,
        s = o.m_position.x - i.m_position.x,
        a = o.m_position.y - i.m_position.y,
        l = s * i.m_R.col1.x + a * i.m_R.col1.y,
        r = s * i.m_R.col2.x + a * i.m_R.col2.y,
        m = 0,
        _ = -Number.MAX_VALUE,
        h = 0;
      e > h;
      ++h
    ) {
      var c = i.m_normals[h].x * l + i.m_normals[h].y * r;
      c > _ && ((_ = c), (m = h));
    }
    var u = b2Collision.EdgeSeparation(i, m, o);
    if (u > 0 && 0 == n) return u;
    var y = m - 1 >= 0 ? m - 1 : e - 1,
      b = b2Collision.EdgeSeparation(i, y, o);
    if (b > 0 && 0 == n) return b;
    var p = e > m + 1 ? m + 1 : 0,
      x = b2Collision.EdgeSeparation(i, p, o);
    if (x > 0 && 0 == n) return x;
    var d,
      v = 0,
      f = 0;
    if (b > u && b > x) (f = -1), (v = y), (d = b);
    else {
      if (!(x > u)) return (t[0] = m), u;
      (f = 1), (v = p), (d = x);
    }
    for (;;) {
      if (
        ((m = -1 == f ? (v - 1 >= 0 ? v - 1 : e - 1) : e > v + 1 ? v + 1 : 0),
        (u = b2Collision.EdgeSeparation(i, m, o)),
        u > 0 && 0 == n)
      )
        return u;
      if (!(u > d)) break;
      (v = m), (d = u);
    }
    return (t[0] = v), d;
  }),
  (b2Collision.FindIncidentEdge = function (t, i, o, n) {
    var e = i.m_vertexCount,
      s = i.m_vertices,
      a = n.m_vertexCount,
      l = n.m_vertices,
      r = o,
      m = o + 1 == e ? 0 : o + 1,
      _ = s[m],
      h = _.x,
      c = _.y;
    (_ = s[r]), (h -= _.x), (c -= _.y);
    var u = h;
    (h = c), (c = -u);
    var y = 1 / Math.sqrt(h * h + c * c);
    (h *= y), (c *= y);
    var b = h,
      p = c;
    u = b;
    var x = i.m_R;
    (b = x.col1.x * u + x.col2.x * p), (p = x.col1.y * u + x.col2.y * p);
    var d = b,
      v = p;
    (x = n.m_R),
      (u = d * x.col1.x + v * x.col1.y),
      (v = d * x.col2.x + v * x.col2.y),
      (d = u);
    for (var f = 0, g = 0, M = Number.MAX_VALUE, V = 0; a > V; ++V) {
      var S = V,
        C = a > V + 1 ? V + 1 : 0;
      _ = l[C];
      var A = _.x,
        w = _.y;
      (_ = l[S]),
        (A -= _.x),
        (w -= _.y),
        (u = A),
        (A = w),
        (w = -u),
        (y = 1 / Math.sqrt(A * A + w * w)),
        (A *= y),
        (w *= y);
      var P = A * d + w * v;
      M > P && ((M = P), (f = S), (g = C));
    }
    var I;
    (I = t[0]),
      (_ = I.v),
      _.SetV(l[f]),
      _.MulM(n.m_R),
      _.Add(n.m_position),
      (I.id.features.referenceFace = o),
      (I.id.features.incidentEdge = f),
      (I.id.features.incidentVertex = f),
      (I = t[1]),
      (_ = I.v),
      _.SetV(l[g]),
      _.MulM(n.m_R),
      _.Add(n.m_position),
      (I.id.features.referenceFace = o),
      (I.id.features.incidentEdge = f),
      (I.id.features.incidentVertex = g);
  }),
  (b2Collision.b2CollidePolyTempVec = new b2Vec2()),
  (b2Collision.b2CollidePoly = function (t, i, o, n) {
    t.pointCount = 0;
    var e = 0,
      s = [e],
      a = b2Collision.FindMaxSeparation(s, i, o, n);
    if (((e = s[0]), !(a > 0 && 0 == n))) {
      var l = 0,
        r = [l],
        m = b2Collision.FindMaxSeparation(r, o, i, n);
      if (((l = r[0]), !(m > 0 && 0 == n))) {
        var _,
          h,
          c = 0,
          u = 0,
          y = 0.98,
          b = 0.001;
        m > y * a + b
          ? ((_ = o), (h = i), (c = l), (u = 1))
          : ((_ = i), (h = o), (c = e), (u = 0));
        var p = [new ClipVertex(), new ClipVertex()];
        b2Collision.FindIncidentEdge(p, _, c, h);
        var x = _.m_vertexCount,
          d = _.m_vertices,
          v = d[c],
          f = x > c + 1 ? d[c + 1] : d[0],
          g = (f.x - v.x, f.y - v.y, f.x - v.x),
          M = f.y - v.y,
          V = g,
          S = _.m_R;
        (g = S.col1.x * V + S.col2.x * M), (M = S.col1.y * V + S.col2.y * M);
        var C = 1 / Math.sqrt(g * g + M * M);
        (g *= C), (M *= C);
        var A = g,
          w = M;
        (V = A), (A = w), (w = -V);
        var P = v.x,
          I = v.y;
        (V = P),
          (S = _.m_R),
          (P = S.col1.x * V + S.col2.x * I),
          (I = S.col1.y * V + S.col2.y * I),
          (P += _.m_position.x),
          (I += _.m_position.y);
        var B = f.x,
          R = f.y;
        (V = B),
          (S = _.m_R),
          (B = S.col1.x * V + S.col2.x * R),
          (R = S.col1.y * V + S.col2.y * R),
          (B += _.m_position.x),
          (R += _.m_position.y);
        var J = A * P + w * I,
          L = -(g * P + M * I),
          D = g * B + M * R,
          F = [new ClipVertex(), new ClipVertex()],
          j = [new ClipVertex(), new ClipVertex()],
          T = 0;
        if (
          (b2Collision.b2CollidePolyTempVec.Set(-g, -M),
          (T = b2Collision.ClipSegmentToLine(
            F,
            p,
            b2Collision.b2CollidePolyTempVec,
            L
          )),
          !(
            2 > T ||
            (b2Collision.b2CollidePolyTempVec.Set(g, M),
            (T = b2Collision.ClipSegmentToLine(
              j,
              F,
              b2Collision.b2CollidePolyTempVec,
              D
            )),
            2 > T)
          ))
        ) {
          u ? t.normal.Set(-A, -w) : t.normal.Set(A, w);
          for (var G = 0, z = 0; z < b2Settings.b2_maxManifoldPoints; ++z) {
            var k = j[z].v,
              Q = A * k.x + w * k.y - J;
            if (0 >= Q || 1 == n) {
              var q = t.points[G];
              (q.separation = Q),
                q.position.SetV(j[z].v),
                q.id.Set(j[z].id),
                (q.id.features.flip = u),
                ++G;
            }
          }
          t.pointCount = G;
        }
      }
    }
  }),
  (b2Collision.b2CollideCircle = function (t, i, o, n) {
    t.pointCount = 0;
    var e = o.m_position.x - i.m_position.x,
      s = o.m_position.y - i.m_position.y,
      a = e * e + s * s,
      l = i.m_radius + o.m_radius;
    if (!(a > l * l && 0 == n)) {
      var r;
      if (a < Number.MIN_VALUE) (r = -l), t.normal.Set(0, 1);
      else {
        var m = Math.sqrt(a);
        r = m - l;
        var _ = 1 / m;
        (t.normal.x = _ * e), (t.normal.y = _ * s);
      }
      t.pointCount = 1;
      var h = t.points[0];
      h.id.set_key(0),
        (h.separation = r),
        (h.position.x = o.m_position.x - o.m_radius * t.normal.x),
        (h.position.y = o.m_position.y - o.m_radius * t.normal.y);
    }
  }),
  (b2Collision.b2CollidePolyAndCircle = function (t, i, o, n) {
    t.pointCount = 0;
    var e,
      s,
      a,
      l = o.m_position.x - i.m_position.x,
      r = o.m_position.y - i.m_position.y,
      m = i.m_R,
      _ = l * m.col1.x + r * m.col1.y;
    (r = l * m.col2.x + r * m.col2.y), (l = _);
    for (
      var h, c = 0, u = -Number.MAX_VALUE, y = o.m_radius, b = 0;
      b < i.m_vertexCount;
      ++b
    ) {
      var p =
        i.m_normals[b].x * (l - i.m_vertices[b].x) +
        i.m_normals[b].y * (r - i.m_vertices[b].y);
      if (p > y) return;
      p > u && ((u = p), (c = b));
    }
    if (u < Number.MIN_VALUE) {
      t.pointCount = 1;
      var x = i.m_normals[c];
      return (
        (t.normal.x = m.col1.x * x.x + m.col2.x * x.y),
        (t.normal.y = m.col1.y * x.x + m.col2.y * x.y),
        (e = t.points[0]),
        (e.id.features.incidentEdge = c),
        (e.id.features.incidentVertex = b2Collision.b2_nullFeature),
        (e.id.features.referenceFace = b2Collision.b2_nullFeature),
        (e.id.features.flip = 0),
        (e.position.x = o.m_position.x - y * t.normal.x),
        (e.position.y = o.m_position.y - y * t.normal.y),
        void (e.separation = u - y)
      );
    }
    var d = c,
      v = d + 1 < i.m_vertexCount ? d + 1 : 0,
      f = i.m_vertices[v].x - i.m_vertices[d].x,
      g = i.m_vertices[v].y - i.m_vertices[d].y,
      M = Math.sqrt(f * f + g * g);
    if (((f /= M), (g /= M), M < Number.MIN_VALUE)) {
      if (
        ((s = l - i.m_vertices[d].x),
        (a = r - i.m_vertices[d].y),
        (h = Math.sqrt(s * s + a * a)),
        (s /= h),
        (a /= h),
        h > y)
      )
        return;
      return (
        (t.pointCount = 1),
        t.normal.Set(m.col1.x * s + m.col2.x * a, m.col1.y * s + m.col2.y * a),
        (e = t.points[0]),
        (e.id.features.incidentEdge = b2Collision.b2_nullFeature),
        (e.id.features.incidentVertex = d),
        (e.id.features.referenceFace = b2Collision.b2_nullFeature),
        (e.id.features.flip = 0),
        (e.position.x = o.m_position.x - y * t.normal.x),
        (e.position.y = o.m_position.y - y * t.normal.y),
        void (e.separation = h - y)
      );
    }
    var V = (l - i.m_vertices[d].x) * f + (r - i.m_vertices[d].y) * g;
    (e = t.points[0]),
      (e.id.features.incidentEdge = b2Collision.b2_nullFeature),
      (e.id.features.incidentVertex = b2Collision.b2_nullFeature),
      (e.id.features.referenceFace = b2Collision.b2_nullFeature),
      (e.id.features.flip = 0);
    var S, C;
    0 >= V
      ? ((S = i.m_vertices[d].x),
        (C = i.m_vertices[d].y),
        (e.id.features.incidentVertex = d))
      : V >= M
      ? ((S = i.m_vertices[v].x),
        (C = i.m_vertices[v].y),
        (e.id.features.incidentVertex = v))
      : ((S = f * V + i.m_vertices[d].x),
        (C = g * V + i.m_vertices[d].y),
        (e.id.features.incidentEdge = d)),
      (s = l - S),
      (a = r - C),
      (h = Math.sqrt(s * s + a * a)),
      (s /= h),
      (a /= h),
      h > y ||
        ((t.pointCount = 1),
        t.normal.Set(m.col1.x * s + m.col2.x * a, m.col1.y * s + m.col2.y * a),
        (e.position.x = o.m_position.x - y * t.normal.x),
        (e.position.y = o.m_position.y - y * t.normal.y),
        (e.separation = h - y));
  }),
  (b2Collision.b2TestOverlap = function (t, i) {
    var o = i.minVertex,
      n = t.maxVertex,
      e = o.x - n.x,
      s = o.y - n.y;
    (o = t.minVertex), (n = i.maxVertex);
    var a = o.x - n.x,
      l = o.y - n.y;
    return e > 0 || s > 0 ? !1 : !(a > 0 || l > 0);
  });
var Features = new b2Root();
jQuery.extend(Features.prototype, {
  set_referenceFace: function (t) {
    (this._referenceFace = t),
      (this._m_id._key =
        (4294967040 & this._m_id._key) | (255 & this._referenceFace));
  },
  get_referenceFace: function () {
    return this._referenceFace;
  },
  _referenceFace: 0,
  set_incidentEdge: function (t) {
    (this._incidentEdge = t),
      (this._m_id._key =
        (4294902015 & this._m_id._key) | ((this._incidentEdge << 8) & 65280));
  },
  get_incidentEdge: function () {
    return this._incidentEdge;
  },
  _incidentEdge: 0,
  set_incidentVertex: function (t) {
    (this._incidentVertex = t),
      (this._m_id._key =
        (4278255615 & this._m_id._key) |
        ((this._incidentVertex << 16) & 16711680));
  },
  get_incidentVertex: function () {
    return this._incidentVertex;
  },
  _incidentVertex: 0,
  set_flip: function (t) {
    (this._flip = t),
      (this._m_id._key =
        (16777215 & this._m_id._key) | ((this._flip << 24) & 4278190080));
  },
  get_flip: function () {
    return this._flip;
  },
  _flip: 0,
  _m_id: null,
  initialize: function () {},
});
var b2ContactID = new b2Root();
jQuery.extend(b2ContactID.prototype, {
  initialize: function () {
    (this.features = new Features()), (this.features._m_id = this);
  },
  Set: function (t) {
    this.set_key(t._key);
  },
  Copy: function () {
    var t = new b2ContactID();
    return t.set_key(this._key), t;
  },
  get_key: function () {
    return this._key;
  },
  set_key: function (t) {
    (this._key = t),
      (this.features._referenceFace = 255 & this._key),
      (this.features._incidentEdge = ((65280 & this._key) >> 8) & 255),
      (this.features._incidentVertex = ((16711680 & this._key) >> 16) & 255),
      (this.features._flip = ((4278190080 & this._key) >> 24) & 255);
  },
  features: new Features(),
  _key: 0,
});
var b2ContactPoint = new b2Root();
jQuery.extend(b2ContactPoint.prototype, {
  position: new b2Vec2(),
  separation: null,
  normalImpulse: null,
  tangentImpulse: null,
  id: new b2ContactID(),
  initialize: function () {
    (this.position = new b2Vec2()), (this.id = new b2ContactID());
  },
});
var b2Distance = new b2Root();
jQuery.extend(b2Distance.prototype, { initialize: function () {} }),
  (b2Distance.ProcessTwo = function (t, i, o, n, e) {
    var s = -e[1].x,
      a = -e[1].y,
      l = e[0].x - e[1].x,
      r = e[0].y - e[1].y,
      m = Math.sqrt(l * l + r * r);
    (l /= m), (r /= m);
    var _ = s * l + a * r;
    return 0 >= _ || m < Number.MIN_VALUE
      ? (t.SetV(o[1]),
        i.SetV(n[1]),
        o[0].SetV(o[1]),
        n[0].SetV(n[1]),
        e[0].SetV(e[1]),
        1)
      : ((_ /= m),
        (t.x = o[1].x + _ * (o[0].x - o[1].x)),
        (t.y = o[1].y + _ * (o[0].y - o[1].y)),
        (i.x = n[1].x + _ * (n[0].x - n[1].x)),
        (i.y = n[1].y + _ * (n[0].y - n[1].y)),
        2);
  }),
  (b2Distance.ProcessThree = function (t, i, o, n, e) {
    var s = e[0].x,
      a = e[0].y,
      l = e[1].x,
      r = e[1].y,
      m = e[2].x,
      _ = e[2].y,
      h = l - s,
      c = r - a,
      u = m - s,
      y = _ - a,
      b = m - l,
      p = _ - r,
      x = -(s * u + a * y),
      d = m * u + _ * y,
      v = -(l * b + r * p),
      f = m * b + _ * p;
    if (0 >= d && 0 >= f)
      return (
        t.SetV(o[2]),
        i.SetV(n[2]),
        o[0].SetV(o[2]),
        n[0].SetV(n[2]),
        e[0].SetV(e[2]),
        1
      );
    var g = h * y - c * u,
      M = g * (s * r - a * l),
      V = g * (l * _ - r * m);
    if (0 >= V && v >= 0 && f >= 0) {
      var S = v / (v + f);
      return (
        (t.x = o[1].x + S * (o[2].x - o[1].x)),
        (t.y = o[1].y + S * (o[2].y - o[1].y)),
        (i.x = n[1].x + S * (n[2].x - n[1].x)),
        (i.y = n[1].y + S * (n[2].y - n[1].y)),
        o[0].SetV(o[2]),
        n[0].SetV(n[2]),
        e[0].SetV(e[2]),
        2
      );
    }
    var C = g * (m * a - _ * s);
    if (0 >= C && x >= 0 && d >= 0) {
      var S = x / (x + d);
      return (
        (t.x = o[0].x + S * (o[2].x - o[0].x)),
        (t.y = o[0].y + S * (o[2].y - o[0].y)),
        (i.x = n[0].x + S * (n[2].x - n[0].x)),
        (i.y = n[0].y + S * (n[2].y - n[0].y)),
        o[1].SetV(o[2]),
        n[1].SetV(n[2]),
        e[1].SetV(e[2]),
        2
      );
    }
    var A = V + C + M;
    A = 1 / A;
    var w = V * A,
      P = C * A,
      I = 1 - w - P;
    return (
      (t.x = w * o[0].x + P * o[1].x + I * o[2].x),
      (t.y = w * o[0].y + P * o[1].y + I * o[2].y),
      (i.x = w * n[0].x + P * n[1].x + I * n[2].x),
      (i.y = w * n[0].y + P * n[1].y + I * n[2].y),
      3
    );
  }),
  (b2Distance.InPoinsts = function (t, i, o) {
    for (var n = 0; o > n; ++n) if (t.x == i[n].x && t.y == i[n].y) return !0;
    return !1;
  }),
  (b2Distance.Distance = function (t, i, o, n) {
    var e = new Array(3),
      s = new Array(3),
      a = new Array(3),
      l = 0;
    t.SetV(o.m_position), i.SetV(n.m_position);
    for (var r = 0, m = 20, _ = 0; m > _; ++_) {
      var h = i.x - t.x,
        c = i.y - t.y,
        u = o.Support(h, c),
        y = n.Support(-h, -c);
      r = h * h + c * c;
      var b = y.x - u.x,
        p = y.y - u.y;
      if (r - b2Dot(h * b + c * p) <= 0.01 * r)
        return (
          0 == l && (t.SetV(u), i.SetV(y)),
          (b2Distance.g_GJK_Iterations = _),
          Math.sqrt(r)
        );
      switch (l) {
        case 0:
          e[0].SetV(u),
            s[0].SetV(y),
            (a[0] = w),
            t.SetV(e[0]),
            i.SetV(s[0]),
            ++l;
          break;
        case 1:
          e[1].SetV(u),
            s[1].SetV(y),
            (a[1].x = b),
            (a[1].y = p),
            (l = b2Distance.ProcessTwo(t, i, e, s, a));
          break;
        case 2:
          e[2].SetV(u),
            s[2].SetV(y),
            (a[2].x = b),
            (a[2].y = p),
            (l = b2Distance.ProcessThree(t, i, e, s, a));
      }
      if (3 == l) return (b2Distance.g_GJK_Iterations = _), 0;
      for (var x = -Number.MAX_VALUE, d = 0; l > d; ++d)
        x = b2Math.b2Max(x, a[d].x * a[d].x + a[d].y * a[d].y);
      if (3 == l || r <= 100 * Number.MIN_VALUE * x)
        return (b2Distance.g_GJK_Iterations = _), Math.sqrt(r);
    }
    return (b2Distance.g_GJK_Iterations = m), Math.sqrt(r);
  }),
  (b2Distance.g_GJK_Iterations = 0);
var b2Manifold = new b2Root();
jQuery.extend(b2Manifold.prototype, {
  initialize: function () {
    this.points = new Array(b2Settings.b2_maxManifoldPoints);
    for (var t = 0; t < b2Settings.b2_maxManifoldPoints; t++)
      this.points[t] = new b2ContactPoint();
    this.normal = new b2Vec2();
  },
  points: null,
  normal: null,
  pointCount: 0,
});
var b2Proxy = new b2Root();
jQuery.extend(b2Proxy.prototype, {
  GetNext: function () {
    return this.lowerBounds[0];
  },
  SetNext: function (t) {
    this.lowerBounds[0] = t;
  },
  IsValid: function () {
    return this.overlapCount != b2BroadPhase.b2_invalid;
  },
  lowerBounds: [0, 0],
  upperBounds: [0, 0],
  overlapCount: 0,
  timeStamp: 0,
  userData: null,
  initialize: function () {
    (this.lowerBounds = [0, 0]), (this.upperBounds = [0, 0]);
  },
});
var ClipVertex = new b2Root();
jQuery.extend(ClipVertex.prototype, {
  v: new b2Vec2(),
  id: new b2ContactID(),
  initialize: function () {
    (this.v = new b2Vec2()), (this.id = new b2ContactID());
  },
});
var b2BodyDef = new b2Root();
jQuery.extend(b2BodyDef.prototype, {
  initialize: function () {
    (this.shapes = new Array()), (this.userData = null);
    for (var t = 0; t < b2Settings.b2_maxShapesPerBody; t++)
      this.shapes[t] = null;
    (this.position = new b2Vec2(0, 0)),
      (this.rotation = 0),
      (this.linearVelocity = new b2Vec2(0, 0)),
      (this.angularVelocity = 0),
      (this.linearDamping = 0),
      (this.angularDamping = 0),
      (this.allowSleep = !0),
      (this.isSleeping = !1),
      (this.preventRotation = !1);
  },
  userData: null,
  shapes: new Array(),
  position: null,
  rotation: null,
  linearVelocity: null,
  angularVelocity: null,
  linearDamping: null,
  angularDamping: null,
  allowSleep: null,
  isSleeping: null,
  preventRotation: null,
  AddShape: function (t) {
    for (var i = 0; i < b2Settings.b2_maxShapesPerBody; ++i)
      if (null == this.shapes[i]) {
        this.shapes[i] = t;
        break;
      }
  },
});
var b2Body = new b2Root();
jQuery.extend(b2Body.prototype, {
  SetOriginPosition: function (t, i) {
    if (!this.IsFrozen()) {
      (this.m_rotation = i),
        this.m_R.Set(this.m_rotation),
        (this.m_position = b2Math.AddVV(
          t,
          b2Math.b2MulMV(this.m_R, this.m_center)
        )),
        this.m_position0.SetV(this.m_position),
        (this.m_rotation0 = this.m_rotation);
      for (var o = this.m_shapeList; null != o; o = o.m_next)
        o.Synchronize(this.m_position, this.m_R, this.m_position, this.m_R);
      this.m_world.m_broadPhase.Commit();
    }
  },
  GetOriginPosition: function () {
    return b2Math.SubtractVV(
      this.m_position,
      b2Math.b2MulMV(this.m_R, this.m_center)
    );
  },
  SetCenterPosition: function (t, i) {
    if (!this.IsFrozen()) {
      (this.m_rotation = i),
        this.m_R.Set(this.m_rotation),
        this.m_position.SetV(t),
        this.m_position0.SetV(this.m_position),
        (this.m_rotation0 = this.m_rotation);
      for (var o = this.m_shapeList; null != o; o = o.m_next)
        o.Synchronize(this.m_position, this.m_R, this.m_position, this.m_R);
      this.m_world.m_broadPhase.Commit();
    }
  },
  GetCenterPosition: function () {
    return this.m_position;
  },
  GetRotation: function () {
    return this.m_rotation;
  },
  GetRotationMatrix: function () {
    return this.m_R;
  },
  SetLinearVelocity: function (t) {
    this.m_linearVelocity.SetV(t);
  },
  GetLinearVelocity: function () {
    return this.m_linearVelocity;
  },
  SetAngularVelocity: function (t) {
    this.m_angularVelocity = t;
  },
  GetAngularVelocity: function () {
    return this.m_angularVelocity;
  },
  ApplyForce: function (t, i) {
    0 == this.IsSleeping() &&
      (this.m_force.Add(t),
      (this.m_torque += b2Math.b2CrossVV(
        b2Math.SubtractVV(i, this.m_position),
        t
      )));
  },
  ApplyTorque: function (t) {
    0 == this.IsSleeping() && (this.m_torque += t);
  },
  ApplyImpulse: function (t, i) {
    0 == this.IsSleeping() &&
      (this.m_linearVelocity.Add(b2Math.MulFV(this.m_invMass, t)),
      (this.m_angularVelocity +=
        this.m_invI *
        b2Math.b2CrossVV(b2Math.SubtractVV(i, this.m_position), t)));
  },
  GetMass: function () {
    return this.m_mass;
  },
  GetInertia: function () {
    return this.m_I;
  },
  GetWorldPoint: function (t) {
    return b2Math.AddVV(this.m_position, b2Math.b2MulMV(this.m_R, t));
  },
  GetWorldVector: function (t) {
    return b2Math.b2MulMV(this.m_R, t);
  },
  GetLocalPoint: function (t) {
    return b2Math.b2MulTMV(this.m_R, b2Math.SubtractVV(t, this.m_position));
  },
  GetLocalVector: function (t) {
    return b2Math.b2MulTMV(this.m_R, t);
  },
  IsStatic: function () {
    return (this.m_flags & b2Body.e_staticFlag) == b2Body.e_staticFlag;
  },
  IsFrozen: function () {
    return (this.m_flags & b2Body.e_frozenFlag) == b2Body.e_frozenFlag;
  },
  IsSleeping: function () {
    return (this.m_flags & b2Body.e_sleepFlag) == b2Body.e_sleepFlag;
  },
  AllowSleeping: function (t) {
    t
      ? (this.m_flags |= b2Body.e_allowSleepFlag)
      : ((this.m_flags &= ~b2Body.e_allowSleepFlag), this.WakeUp());
  },
  WakeUp: function () {
    (this.m_flags &= ~b2Body.e_sleepFlag), (this.m_sleepTime = 0);
  },
  GetShapeList: function () {
    return this.m_shapeList;
  },
  GetContactList: function () {
    return this.m_contactList;
  },
  GetJointList: function () {
    return this.m_jointList;
  },
  GetNext: function () {
    return this.m_next;
  },
  GetUserData: function () {
    return this.m_userData;
  },
  initialize: function (t, i) {
    (this.sMat0 = new b2Mat22()),
      (this.m_position = new b2Vec2()),
      (this.m_R = new b2Mat22(0)),
      (this.m_position0 = new b2Vec2());
    var o,
      n,
      e = 0;
    (this.m_flags = 0),
      this.m_position.SetV(t.position),
      (this.m_rotation = t.rotation),
      this.m_R.Set(this.m_rotation),
      this.m_position0.SetV(this.m_position),
      (this.m_rotation0 = this.m_rotation),
      (this.m_world = i),
      (this.m_linearDamping = b2Math.b2Clamp(1 - t.linearDamping, 0, 1)),
      (this.m_angularDamping = b2Math.b2Clamp(1 - t.angularDamping, 0, 1)),
      (this.m_force = new b2Vec2(0, 0)),
      (this.m_torque = 0),
      (this.m_mass = 0);
    var s = new Array(b2Settings.b2_maxShapesPerBody);
    for (e = 0; e < b2Settings.b2_maxShapesPerBody; e++)
      s[e] = new b2MassData();
    for (
      this.m_shapeCount = 0, this.m_center = new b2Vec2(0, 0), e = 0;
      e < b2Settings.b2_maxShapesPerBody && ((o = t.shapes[e]), null != o);
      ++e
    )
      (n = s[e]),
        o.ComputeMass(n),
        (this.m_mass += n.mass),
        (this.m_center.x += n.mass * (o.localPosition.x + n.center.x)),
        (this.m_center.y += n.mass * (o.localPosition.y + n.center.y)),
        ++this.m_shapeCount;
    for (
      this.m_mass > 0
        ? (this.m_center.Multiply(1 / this.m_mass),
          this.m_position.Add(b2Math.b2MulMV(this.m_R, this.m_center)))
        : (this.m_flags |= b2Body.e_staticFlag),
        this.m_I = 0,
        e = 0;
      e < this.m_shapeCount;
      ++e
    ) {
      (o = t.shapes[e]), (n = s[e]), (this.m_I += n.I);
      var a = b2Math.SubtractVV(
        b2Math.AddVV(o.localPosition, n.center),
        this.m_center
      );
      this.m_I += n.mass * b2Math.b2Dot(a, a);
    }
    for (
      this.m_mass > 0
        ? (this.m_invMass = 1 / this.m_mass)
        : (this.m_invMass = 0),
        this.m_I > 0 && 0 == t.preventRotation
          ? (this.m_invI = 1 / this.m_I)
          : ((this.m_I = 0), (this.m_invI = 0)),
        this.m_linearVelocity = b2Math.AddVV(
          t.linearVelocity,
          b2Math.b2CrossFV(t.angularVelocity, this.m_center)
        ),
        this.m_angularVelocity = t.angularVelocity,
        this.m_jointList = null,
        this.m_contactList = null,
        this.m_prev = null,
        this.m_next = null,
        this.m_shapeList = null,
        e = 0;
      e < this.m_shapeCount;
      ++e
    ) {
      o = t.shapes[e];
      var l = b2Shape.Create(o, this, this.m_center);
      (l.m_next = this.m_shapeList), (this.m_shapeList = l);
    }
    (this.m_sleepTime = 0),
      t.allowSleep && (this.m_flags |= b2Body.e_allowSleepFlag),
      t.isSleeping && (this.m_flags |= b2Body.e_sleepFlag),
      (this.m_flags & b2Body.e_sleepFlag || 0 == this.m_invMass) &&
        (this.m_linearVelocity.Set(0, 0), (this.m_angularVelocity = 0)),
      (this.m_userData = t.userData);
  },
  Destroy: function () {
    for (var t = this.m_shapeList; t; ) {
      var i = t;
      (t = t.m_next), b2Shape.Destroy(i);
    }
  },
  sMat0: new b2Mat22(),
  SynchronizeShapes: function () {
    this.sMat0.Set(this.m_rotation0);
    for (var t = this.m_shapeList; null != t; t = t.m_next)
      t.Synchronize(this.m_position0, this.sMat0, this.m_position, this.m_R);
  },
  QuickSyncShapes: function () {
    for (var t = this.m_shapeList; null != t; t = t.m_next)
      t.QuickSync(this.m_position, this.m_R);
  },
  IsConnected: function (t) {
    for (var i = this.m_jointList; null != i; i = i.next)
      if (i.other == t) return 0 == i.joint.m_collideConnected;
    return !1;
  },
  Freeze: function () {
    (this.m_flags |= b2Body.e_frozenFlag),
      this.m_linearVelocity.SetZero(),
      (this.m_angularVelocity = 0);
    for (var t = this.m_shapeList; null != t; t = t.m_next) t.DestroyProxy();
  },
  m_flags: 0,
  m_position: new b2Vec2(),
  m_rotation: null,
  m_R: new b2Mat22(0),
  m_position0: new b2Vec2(),
  m_rotation0: null,
  m_linearVelocity: null,
  m_angularVelocity: null,
  m_force: null,
  m_torque: null,
  m_center: null,
  m_world: null,
  m_prev: null,
  m_next: null,
  m_shapeList: null,
  m_shapeCount: 0,
  m_jointList: null,
  m_contactList: null,
  m_mass: null,
  m_invMass: null,
  m_I: null,
  m_invI: null,
  m_linearDamping: null,
  m_angularDamping: null,
  m_sleepTime: null,
  m_userData: null,
}),
  (b2Body.e_staticFlag = 1),
  (b2Body.e_frozenFlag = 2),
  (b2Body.e_islandFlag = 4),
  (b2Body.e_sleepFlag = 8),
  (b2Body.e_allowSleepFlag = 16),
  (b2Body.e_destroyFlag = 32);
var b2CollisionFilter = new b2Root();
jQuery.extend(b2CollisionFilter.prototype, {
  ShouldCollide: function (t, i) {
    if (t.m_groupIndex == i.m_groupIndex && 0 != t.m_groupIndex)
      return t.m_groupIndex > 0;
    var o =
      0 != (t.m_maskBits & i.m_categoryBits) &&
      0 != (t.m_categoryBits & i.m_maskBits);
    return o;
  },
  initialize: function () {},
}),
  (b2CollisionFilter.b2_defaultFilter = new b2CollisionFilter());
var b2ContactNode = new b2Root();
jQuery.extend(b2ContactNode.prototype, {
  other: null,
  contact: null,
  prev: null,
  next: null,
  initialize: function () {},
});
var b2Contact = new b2Root();
jQuery.extend(b2Contact.prototype, {
  GetManifolds: function () {
    return null;
  },
  GetManifoldCount: function () {
    return this.m_manifoldCount;
  },
  GetNext: function () {
    return this.m_next;
  },
  GetShape1: function () {
    return this.m_shape1;
  },
  GetShape2: function () {
    return this.m_shape2;
  },
  initialize: function (t, i) {
    return (
      (this.m_node1 = new b2ContactNode()),
      (this.m_node2 = new b2ContactNode()),
      (this.m_flags = 0),
      t && i
        ? ((this.m_shape1 = t),
          (this.m_shape2 = i),
          (this.m_manifoldCount = 0),
          (this.m_friction = Math.sqrt(
            this.m_shape1.m_friction * this.m_shape2.m_friction
          )),
          (this.m_restitution = b2Math.b2Max(
            this.m_shape1.m_restitution,
            this.m_shape2.m_restitution
          )),
          (this.m_prev = null),
          (this.m_next = null),
          (this.m_node1.contact = null),
          (this.m_node1.prev = null),
          (this.m_node1.next = null),
          (this.m_node1.other = null),
          (this.m_node2.contact = null),
          (this.m_node2.prev = null),
          (this.m_node2.next = null),
          void (this.m_node2.other = null))
        : ((this.m_shape1 = null), void (this.m_shape2 = null))
    );
  },
  Evaluate: function () {},
  m_flags: 0,
  m_prev: null,
  m_next: null,
  m_node1: new b2ContactNode(),
  m_node2: new b2ContactNode(),
  m_shape1: null,
  m_shape2: null,
  m_manifoldCount: 0,
  m_friction: null,
  m_restitution: null,
}),
  (b2Contact.e_islandFlag = 1),
  (b2Contact.e_destroyFlag = 2),
  (b2Contact.AddType = function (t, i, o, n) {
    (b2Contact.s_registers[o][n].createFcn = t),
      (b2Contact.s_registers[o][n].destroyFcn = i),
      (b2Contact.s_registers[o][n].primary = !0),
      o != n &&
        ((b2Contact.s_registers[n][o].createFcn = t),
        (b2Contact.s_registers[n][o].destroyFcn = i),
        (b2Contact.s_registers[n][o].primary = !1));
  }),
  (b2Contact.InitializeRegisters = function () {
    b2Contact.s_registers = new Array(b2Shape.e_shapeTypeCount);
    for (var t = 0; t < b2Shape.e_shapeTypeCount; t++) {
      b2Contact.s_registers[t] = new Array(b2Shape.e_shapeTypeCount);
      for (var i = 0; i < b2Shape.e_shapeTypeCount; i++)
        b2Contact.s_registers[t][i] = new b2ContactRegister();
    }
    b2Contact.AddType(
      b2CircleContact.Create,
      b2CircleContact.Destroy,
      b2Shape.e_circleShape,
      b2Shape.e_circleShape
    ),
      b2Contact.AddType(
        b2PolyAndCircleContact.Create,
        b2PolyAndCircleContact.Destroy,
        b2Shape.e_polyShape,
        b2Shape.e_circleShape
      ),
      b2Contact.AddType(
        b2PolyContact.Create,
        b2PolyContact.Destroy,
        b2Shape.e_polyShape,
        b2Shape.e_polyShape
      );
  }),
  (b2Contact.Create = function (t, i, o) {
    0 == b2Contact.s_initialized &&
      (b2Contact.InitializeRegisters(), (b2Contact.s_initialized = !0));
    var n = t.m_type,
      e = i.m_type,
      s = b2Contact.s_registers[n][e].createFcn;
    if (s) {
      if (b2Contact.s_registers[n][e].primary) return s(t, i, o);
      for (var a = s(i, t, o), l = 0; l < a.GetManifoldCount(); ++l) {
        var r = a.GetManifolds()[l];
        r.normal = r.normal.Negative();
      }
      return a;
    }
    return null;
  }),
  (b2Contact.Destroy = function (t, i) {
    t.GetManifoldCount() > 0 &&
      (t.m_shape1.m_body.WakeUp(), t.m_shape2.m_body.WakeUp());
    var o = t.m_shape1.m_type,
      n = t.m_shape2.m_type,
      e = b2Contact.s_registers[o][n].destroyFcn;
    e(t, i);
  }),
  (b2Contact.s_registers = null),
  (b2Contact.s_initialized = !1);
var b2CircleContact = new b2Root();
jQuery.extend(b2CircleContact.prototype, b2Contact.prototype),
  jQuery.extend(b2CircleContact.prototype, {
    initialize: function (t, i) {
      return (
        (this.m_node1 = new b2ContactNode()),
        (this.m_node2 = new b2ContactNode()),
        (this.m_flags = 0),
        t && i
          ? ((this.m_shape1 = t),
            (this.m_shape2 = i),
            (this.m_manifoldCount = 0),
            (this.m_friction = Math.sqrt(
              this.m_shape1.m_friction * this.m_shape2.m_friction
            )),
            (this.m_restitution = b2Math.b2Max(
              this.m_shape1.m_restitution,
              this.m_shape2.m_restitution
            )),
            (this.m_prev = null),
            (this.m_next = null),
            (this.m_node1.contact = null),
            (this.m_node1.prev = null),
            (this.m_node1.next = null),
            (this.m_node1.other = null),
            (this.m_node2.contact = null),
            (this.m_node2.prev = null),
            (this.m_node2.next = null),
            (this.m_node2.other = null),
            (this.m_manifold = [new b2Manifold()]),
            (this.m_manifold[0].pointCount = 0),
            (this.m_manifold[0].points[0].normalImpulse = 0),
            void (this.m_manifold[0].points[0].tangentImpulse = 0))
          : ((this.m_shape1 = null), void (this.m_shape2 = null))
      );
    },
    Evaluate: function () {
      b2Collision.b2CollideCircle(
        this.m_manifold[0],
        this.m_shape1,
        this.m_shape2,
        !1
      ),
        this.m_manifold[0].pointCount > 0
          ? (this.m_manifoldCount = 1)
          : (this.m_manifoldCount = 0);
    },
    GetManifolds: function () {
      return this.m_manifold;
    },
    m_manifold: [new b2Manifold()],
  }),
  (b2CircleContact.Create = function (t, i, o) {
    return new b2CircleContact(t, i);
  }),
  (b2CircleContact.Destroy = function (t, i) {});
var b2Conservative = new b2Root();
jQuery.extend(b2Conservative.prototype, { initialize: function () {} }),
  (b2Conservative.R1 = new b2Mat22()),
  (b2Conservative.R2 = new b2Mat22()),
  (b2Conservative.x1 = new b2Vec2()),
  (b2Conservative.x2 = new b2Vec2()),
  (b2Conservative.Conservative = function (t, i) {
    var o = t.GetBody(),
      n = i.GetBody(),
      e = o.m_position.x - o.m_position0.x,
      s = o.m_position.y - o.m_position0.y,
      a = o.m_rotation - o.m_rotation0,
      l = n.m_position.x - n.m_position0.x,
      r = n.m_position.y - n.m_position0.y,
      m = n.m_rotation - n.m_rotation0,
      _ = t.GetMaxRadius(),
      h = i.GetMaxRadius(),
      c = o.m_position0.x,
      u = o.m_position0.y,
      y = o.m_rotation0,
      b = n.m_position0.x,
      p = n.m_position0.y,
      x = n.m_rotation0,
      v = c,
      f = u,
      g = y,
      M = b,
      V = p,
      S = x;
    b2Conservative.R1.Set(g),
      b2Conservative.R2.Set(S),
      t.QuickSync(p1, b2Conservative.R1),
      i.QuickSync(p2, b2Conservative.R2);
    for (var C, A, w = 0, P = 10, I = 0, B = !0, R = 0; P > R; ++R) {
      var J = b2Distance.Distance(b2Conservative.x1, b2Conservative.x2, t, i);
      if (J < b2Settings.b2_linearSlop) {
        B = 0 != R;
        break;
      }
      if (0 == R) {
        (C = b2Conservative.x2.x - b2Conservative.x1.x),
          (A = b2Conservative.x2.y - b2Conservative.x1.y);
        var L =
          (Math.sqrt(C * C + A * A),
          C * (e - l) + A * (s - r) + Math.abs(a) * _ + Math.abs(m) * h);
        if (Math.abs(L) < Number.MIN_VALUE) {
          B = !1;
          break;
        }
        I = 1 / L;
      }
      var D = J * I,
        F = w + D;
      if (0 > F || F > 1) {
        B = !1;
        break;
      }
      if (F < (1 + 100 * Number.MIN_VALUE) * w) {
        B = !0;
        break;
      }
      (w = F),
        (v = c + w * v1.x),
        (f = u + w * v1.y),
        (g = y + w * a),
        (M = b + w * v2.x),
        (V = p + w * v2.y),
        (S = x + w * m),
        b2Conservative.R1.Set(g),
        b2Conservative.R2.Set(S),
        t.QuickSync(p1, b2Conservative.R1),
        i.QuickSync(p2, b2Conservative.R2);
    }
    if (B) {
      (C = b2Conservative.x2.x - b2Conservative.x1.x),
        (A = b2Conservative.x2.y - b2Conservative.x1.y);
      var j = Math.sqrt(C * C + A * A);
      return (
        j > FLT_EPSILON && (d *= b2_linearSlop / j),
        o.IsStatic()
          ? ((o.m_position.x = v), (o.m_position.y = f))
          : ((o.m_position.x = v - C), (o.m_position.y = f - A)),
        (o.m_rotation = g),
        o.m_R.Set(g),
        o.QuickSyncShapes(),
        n.IsStatic()
          ? ((n.m_position.x = M), (n.m_position.y = V))
          : ((n.m_position.x = M + C), (n.m_position.y = V + A)),
        (n.m_position.x = M + C),
        (n.m_position.y = V + A),
        (n.m_rotation = S),
        n.m_R.Set(S),
        n.QuickSyncShapes(),
        !0
      );
    }
    return (
      t.QuickSync(o.m_position, o.m_R), i.QuickSync(n.m_position, n.m_R), !1
    );
  });
var b2ContactConstraint = new b2Root();
jQuery.extend(b2ContactConstraint.prototype, {
  initialize: function () {
    (this.normal = new b2Vec2()),
      (this.points = new Array(b2Settings.b2_maxManifoldPoints));
    for (var t = 0; t < b2Settings.b2_maxManifoldPoints; t++)
      this.points[t] = new b2ContactConstraintPoint();
  },
  points: null,
  normal: new b2Vec2(),
  manifold: null,
  body1: null,
  body2: null,
  friction: null,
  restitution: null,
  pointCount: 0,
});
var b2ContactConstraintPoint = new b2Root();
jQuery.extend(b2ContactConstraintPoint.prototype, {
  localAnchor1: new b2Vec2(),
  localAnchor2: new b2Vec2(),
  normalImpulse: null,
  tangentImpulse: null,
  positionImpulse: null,
  normalMass: null,
  tangentMass: null,
  separation: null,
  velocityBias: null,
  initialize: function () {
    (this.localAnchor1 = new b2Vec2()), (this.localAnchor2 = new b2Vec2());
  },
});
var b2ContactRegister = new b2Root();
jQuery.extend(b2ContactRegister.prototype, {
  createFcn: null,
  destroyFcn: null,
  primary: null,
  initialize: function () {},
});
var b2ContactSolver = new b2Root();
jQuery.extend(b2ContactSolver.prototype, {
  initialize: function (t, i, o) {
    (this.m_constraints = new Array()), (this.m_allocator = o);
    var n,
      e,
      s = 0;
    for (this.m_constraintCount = 0, s = 0; i > s; ++s)
      this.m_constraintCount += t[s].GetManifoldCount();
    for (s = 0; s < this.m_constraintCount; s++)
      this.m_constraints[s] = new b2ContactConstraint();
    var a = 0;
    for (s = 0; i > s; ++s)
      for (
        var l = t[s],
          r = l.m_shape1.m_body,
          m = l.m_shape2.m_body,
          _ = l.GetManifoldCount(),
          h = l.GetManifolds(),
          c = l.m_friction,
          u = l.m_restitution,
          y = r.m_linearVelocity.x,
          b = r.m_linearVelocity.y,
          p = m.m_linearVelocity.x,
          x = m.m_linearVelocity.y,
          d = r.m_angularVelocity,
          v = m.m_angularVelocity,
          f = 0;
        _ > f;
        ++f
      ) {
        var g = h[f],
          M = g.normal.x,
          V = g.normal.y,
          S = this.m_constraints[a];
        (S.body1 = r),
          (S.body2 = m),
          (S.manifold = g),
          (S.normal.x = M),
          (S.normal.y = V),
          (S.pointCount = g.pointCount),
          (S.friction = c),
          (S.restitution = u);
        for (var C = 0; C < S.pointCount; ++C) {
          var A = g.points[C],
            w = S.points[C];
          (w.normalImpulse = A.normalImpulse),
            (w.tangentImpulse = A.tangentImpulse),
            (w.separation = A.separation);
          var P = A.position.x - r.m_position.x,
            I = A.position.y - r.m_position.y,
            B = A.position.x - m.m_position.x,
            R = A.position.y - m.m_position.y;
          (n = w.localAnchor1),
            (e = r.m_R),
            (n.x = P * e.col1.x + I * e.col1.y),
            (n.y = P * e.col2.x + I * e.col2.y),
            (n = w.localAnchor2),
            (e = m.m_R),
            (n.x = B * e.col1.x + R * e.col1.y),
            (n.y = B * e.col2.x + R * e.col2.y);
          var J = P * P + I * I,
            L = B * B + R * R,
            D = P * M + I * V,
            F = B * M + R * V,
            j = r.m_invMass + m.m_invMass;
          (j += r.m_invI * (J - D * D) + m.m_invI * (L - F * F)),
            (w.normalMass = 1 / j);
          var T = V,
            G = -M,
            z = P * T + I * G,
            k = B * T + R * G,
            Q = r.m_invMass + m.m_invMass;
          (Q += r.m_invI * (J - z * z) + m.m_invI * (L - k * k)),
            (w.tangentMass = 1 / Q),
            (w.velocityBias = 0),
            w.separation > 0 && (w.velocityBias = -60 * w.separation);
          var q = p + -v * R - y - -d * I,
            N = x + v * B - b - d * P,
            K = S.normal.x * q + S.normal.y * N;
          K < -b2Settings.b2_velocityThreshold &&
            (w.velocityBias += -S.restitution * K);
        }
        ++a;
      }
  },
  PreSolve: function () {
    for (var t, i, o = 0; o < this.m_constraintCount; ++o) {
      var n = this.m_constraints[o],
        e = n.body1,
        s = n.body2,
        a = e.m_invMass,
        l = e.m_invI,
        r = s.m_invMass,
        m = s.m_invI,
        _ = n.normal.x,
        h = n.normal.y,
        c = h,
        u = -_,
        y = 0,
        b = 0;
      if (b2World.s_enableWarmStarting)
        for (b = n.pointCount, y = 0; b > y; ++y) {
          var p = n.points[y],
            x = p.normalImpulse * _ + p.tangentImpulse * c,
            d = p.normalImpulse * h + p.tangentImpulse * u;
          (i = e.m_R), (t = p.localAnchor1);
          var v = i.col1.x * t.x + i.col2.x * t.y,
            f = i.col1.y * t.x + i.col2.y * t.y;
          (i = s.m_R), (t = p.localAnchor2);
          var g = i.col1.x * t.x + i.col2.x * t.y,
            M = i.col1.y * t.x + i.col2.y * t.y;
          (e.m_angularVelocity -= l * (v * d - f * x)),
            (e.m_linearVelocity.x -= a * x),
            (e.m_linearVelocity.y -= a * d),
            (s.m_angularVelocity += m * (g * d - M * x)),
            (s.m_linearVelocity.x += r * x),
            (s.m_linearVelocity.y += r * d),
            (p.positionImpulse = 0);
        }
      else
        for (b = n.pointCount, y = 0; b > y; ++y) {
          var V = n.points[y];
          (V.normalImpulse = 0),
            (V.tangentImpulse = 0),
            (V.positionImpulse = 0);
        }
    }
  },
  SolveVelocityConstraints: function () {
    for (
      var t, i, o, n, e, s, a, l, r, m, _, h, c, u = 0, y = 0;
      y < this.m_constraintCount;
      ++y
    ) {
      var b = this.m_constraints[y],
        p = b.body1,
        x = b.body2,
        d = p.m_angularVelocity,
        v = p.m_linearVelocity,
        f = x.m_angularVelocity,
        g = x.m_linearVelocity,
        M = p.m_invMass,
        V = p.m_invI,
        S = x.m_invMass,
        C = x.m_invI,
        A = b.normal.x,
        w = b.normal.y,
        P = w,
        I = -A,
        B = b.pointCount;
      for (u = 0; B > u; ++u) {
        (t = b.points[u]),
          (h = p.m_R),
          (c = t.localAnchor1),
          (i = h.col1.x * c.x + h.col2.x * c.y),
          (o = h.col1.y * c.x + h.col2.y * c.y),
          (h = x.m_R),
          (c = t.localAnchor2),
          (n = h.col1.x * c.x + h.col2.x * c.y),
          (e = h.col1.y * c.x + h.col2.y * c.y),
          (s = g.x + -f * e - v.x - -d * o),
          (a = g.y + f * n - v.y - d * i);
        var R = s * A + a * w;
        (l = -t.normalMass * (R - t.velocityBias)),
          (r = b2Math.b2Max(t.normalImpulse + l, 0)),
          (l = r - t.normalImpulse),
          (m = l * A),
          (_ = l * w),
          (v.x -= M * m),
          (v.y -= M * _),
          (d -= V * (i * _ - o * m)),
          (g.x += S * m),
          (g.y += S * _),
          (f += C * (n * _ - e * m)),
          (t.normalImpulse = r),
          (s = g.x + -f * e - v.x - -d * o),
          (a = g.y + f * n - v.y - d * i);
        var J = s * P + a * I;
        l = t.tangentMass * -J;
        var L = b.friction * t.normalImpulse;
        (r = b2Math.b2Clamp(t.tangentImpulse + l, -L, L)),
          (l = r - t.tangentImpulse),
          (m = l * P),
          (_ = l * I),
          (v.x -= M * m),
          (v.y -= M * _),
          (d -= V * (i * _ - o * m)),
          (g.x += S * m),
          (g.y += S * _),
          (f += C * (n * _ - e * m)),
          (t.tangentImpulse = r);
      }
      (p.m_angularVelocity = d), (x.m_angularVelocity = f);
    }
  },
  SolvePositionConstraints: function (t) {
    for (var i, o, n = 0, e = 0; e < this.m_constraintCount; ++e) {
      for (
        var s = this.m_constraints[e],
          a = s.body1,
          l = s.body2,
          r = a.m_position,
          m = a.m_rotation,
          _ = l.m_position,
          h = l.m_rotation,
          c = a.m_invMass,
          u = a.m_invI,
          y = l.m_invMass,
          b = l.m_invI,
          p = s.normal.x,
          x = s.normal.y,
          d = s.pointCount,
          v = 0;
        d > v;
        ++v
      ) {
        var f = s.points[v];
        (i = a.m_R), (o = f.localAnchor1);
        var g = i.col1.x * o.x + i.col2.x * o.y,
          M = i.col1.y * o.x + i.col2.y * o.y;
        (i = l.m_R), (o = f.localAnchor2);
        var V = i.col1.x * o.x + i.col2.x * o.y,
          S = i.col1.y * o.x + i.col2.y * o.y,
          C = r.x + g,
          A = r.y + M,
          w = _.x + V,
          P = _.y + S,
          I = w - C,
          B = P - A,
          R = I * p + B * x + f.separation;
        n = b2Math.b2Min(n, R);
        var J =
            t *
            b2Math.b2Clamp(
              R + b2Settings.b2_linearSlop,
              -b2Settings.b2_maxLinearCorrection,
              0
            ),
          L = -f.normalMass * J,
          D = f.positionImpulse;
        (f.positionImpulse = b2Math.b2Max(D + L, 0)),
          (L = f.positionImpulse - D);
        var F = L * p,
          j = L * x;
        (r.x -= c * F),
          (r.y -= c * j),
          (m -= u * (g * j - M * F)),
          a.m_R.Set(m),
          (_.x += y * F),
          (_.y += y * j),
          (h += b * (V * j - S * F)),
          l.m_R.Set(h);
      }
      (a.m_rotation = m), (l.m_rotation = h);
    }
    return n >= -b2Settings.b2_linearSlop;
  },
  PostSolve: function () {
    for (var t = 0; t < this.m_constraintCount; ++t)
      for (
        var i = this.m_constraints[t], o = i.manifold, n = 0;
        n < i.pointCount;
        ++n
      ) {
        var e = o.points[n],
          s = i.points[n];
        (e.normalImpulse = s.normalImpulse),
          (e.tangentImpulse = s.tangentImpulse);
      }
  },
  m_allocator: null,
  m_constraints: new Array(),
  m_constraintCount: 0,
});
var b2PolyAndCircleContact = new b2Root();
jQuery.extend(b2PolyAndCircleContact.prototype, b2Contact.prototype),
  jQuery.extend(b2PolyAndCircleContact.prototype, {
    initialize: function (t, i) {
      return (
        (this.m_node1 = new b2ContactNode()),
        (this.m_node2 = new b2ContactNode()),
        (this.m_flags = 0),
        t && i
          ? ((this.m_shape1 = t),
            (this.m_shape2 = i),
            (this.m_manifoldCount = 0),
            (this.m_friction = Math.sqrt(
              this.m_shape1.m_friction * this.m_shape2.m_friction
            )),
            (this.m_restitution = b2Math.b2Max(
              this.m_shape1.m_restitution,
              this.m_shape2.m_restitution
            )),
            (this.m_prev = null),
            (this.m_next = null),
            (this.m_node1.contact = null),
            (this.m_node1.prev = null),
            (this.m_node1.next = null),
            (this.m_node1.other = null),
            (this.m_node2.contact = null),
            (this.m_node2.prev = null),
            (this.m_node2.next = null),
            (this.m_node2.other = null),
            (this.m_manifold = [new b2Manifold()]),
            b2Settings.b2Assert(this.m_shape1.m_type == b2Shape.e_polyShape),
            b2Settings.b2Assert(this.m_shape2.m_type == b2Shape.e_circleShape),
            (this.m_manifold[0].pointCount = 0),
            (this.m_manifold[0].points[0].normalImpulse = 0),
            void (this.m_manifold[0].points[0].tangentImpulse = 0))
          : ((this.m_shape1 = null), void (this.m_shape2 = null))
      );
    },
    Evaluate: function () {
      b2Collision.b2CollidePolyAndCircle(
        this.m_manifold[0],
        this.m_shape1,
        this.m_shape2,
        !1
      ),
        this.m_manifold[0].pointCount > 0
          ? (this.m_manifoldCount = 1)
          : (this.m_manifoldCount = 0);
    },
    GetManifolds: function () {
      return this.m_manifold;
    },
    m_manifold: [new b2Manifold()],
  }),
  (b2PolyAndCircleContact.Create = function (t, i, o) {
    return new b2PolyAndCircleContact(t, i);
  }),
  (b2PolyAndCircleContact.Destroy = function (t, i) {});
var b2PolyContact = new b2Root();
jQuery.extend(b2PolyContact.prototype, b2Contact.prototype),
  jQuery.extend(b2PolyContact.prototype, {
    initialize: function (t, i) {
      return (
        (this.m_node1 = new b2ContactNode()),
        (this.m_node2 = new b2ContactNode()),
        (this.m_flags = 0),
        t && i
          ? ((this.m_shape1 = t),
            (this.m_shape2 = i),
            (this.m_manifoldCount = 0),
            (this.m_friction = Math.sqrt(
              this.m_shape1.m_friction * this.m_shape2.m_friction
            )),
            (this.m_restitution = b2Math.b2Max(
              this.m_shape1.m_restitution,
              this.m_shape2.m_restitution
            )),
            (this.m_prev = null),
            (this.m_next = null),
            (this.m_node1.contact = null),
            (this.m_node1.prev = null),
            (this.m_node1.next = null),
            (this.m_node1.other = null),
            (this.m_node2.contact = null),
            (this.m_node2.prev = null),
            (this.m_node2.next = null),
            (this.m_node2.other = null),
            (this.m0 = new b2Manifold()),
            (this.m_manifold = [new b2Manifold()]),
            void (this.m_manifold[0].pointCount = 0))
          : ((this.m_shape1 = null), void (this.m_shape2 = null))
      );
    },
    m0: new b2Manifold(),
    Evaluate: function () {
      for (
        var t = this.m_manifold[0], i = this.m0.points, o = 0;
        o < t.pointCount;
        o++
      ) {
        var n = i[o],
          e = t.points[o];
        (n.normalImpulse = e.normalImpulse),
          (n.tangentImpulse = e.tangentImpulse),
          (n.id = e.id.Copy());
      }
      if (
        ((this.m0.pointCount = t.pointCount),
        b2Collision.b2CollidePoly(t, this.m_shape1, this.m_shape2, !1),
        t.pointCount > 0)
      ) {
        for (var s = [!1, !1], a = 0; a < t.pointCount; ++a) {
          var l = t.points[a];
          (l.normalImpulse = 0), (l.tangentImpulse = 0);
          for (var r = l.id.key, m = 0; m < this.m0.pointCount; ++m)
            if (1 != s[m]) {
              var _ = this.m0.points[m],
                h = _.id;
              if (h.key == r) {
                (s[m] = !0),
                  (l.normalImpulse = _.normalImpulse),
                  (l.tangentImpulse = _.tangentImpulse);
                break;
              }
            }
        }
        this.m_manifoldCount = 1;
      } else this.m_manifoldCount = 0;
    },
    GetManifolds: function () {
      return this.m_manifold;
    },
    m_manifold: [new b2Manifold()],
  }),
  (b2PolyContact.Create = function (t, i, o) {
    return new b2PolyContact(t, i);
  }),
  (b2PolyContact.Destroy = function (t, i) {});
var b2JointDef = new b2Root();
jQuery.extend(b2JointDef.prototype, {
  initialize: function () {
    (this.type = b2Joint.e_unknownJoint),
      (this.userData = null),
      (this.body1 = null),
      (this.body2 = null),
      (this.collideConnected = !1);
  },
  type: 0,
  userData: null,
  body1: null,
  body2: null,
  collideConnected: null,
});
var b2JointNode = new b2Root();
jQuery.extend(b2JointNode.prototype, {
  other: null,
  joint: null,
  prev: null,
  next: null,
  initialize: function () {},
});
var b2Joint = new b2Root();
jQuery.extend(b2Joint.prototype, {
  GetType: function () {
    return this.m_type;
  },
  GetAnchor1: function () {
    return null;
  },
  GetAnchor2: function () {
    return null;
  },
  GetReactionForce: function (t) {
    return null;
  },
  GetReactionTorque: function (t) {
    return 0;
  },
  GetBody1: function () {
    return this.m_body1;
  },
  GetBody2: function () {
    return this.m_body2;
  },
  GetNext: function () {
    return this.m_next;
  },
  GetUserData: function () {
    return this.m_userData;
  },
  initialize: function (t) {
    (this.m_node1 = new b2JointNode()),
      (this.m_node2 = new b2JointNode()),
      (this.m_type = t.type),
      (this.m_prev = null),
      (this.m_next = null),
      (this.m_body1 = t.body1),
      (this.m_body2 = t.body2),
      (this.m_collideConnected = t.collideConnected),
      (this.m_islandFlag = !1),
      (this.m_userData = t.userData);
  },
  PrepareVelocitySolver: function () {},
  SolveVelocityConstraints: function (t) {},
  PreparePositionSolver: function () {},
  SolvePositionConstraints: function () {
    return !1;
  },
  m_type: 0,
  m_prev: null,
  m_next: null,
  m_node1: new b2JointNode(),
  m_node2: new b2JointNode(),
  m_body1: null,
  m_body2: null,
  m_islandFlag: null,
  m_collideConnected: null,
  m_userData: null,
}),
  (b2Joint.Create = function (t, i) {
    var o = null;
    switch (t.type) {
      case b2Joint.e_distanceJoint:
        o = new b2DistanceJoint(t);
        break;
      case b2Joint.e_mouseJoint:
        o = new b2MouseJoint(t);
        break;
      case b2Joint.e_prismaticJoint:
        o = new b2PrismaticJoint(t);
        break;
      case b2Joint.e_revoluteJoint:
        o = new b2RevoluteJoint(t);
        break;
      case b2Joint.e_pulleyJoint:
        o = new b2PulleyJoint(t);
        break;
      case b2Joint.e_gearJoint:
        o = new b2GearJoint(t);
    }
    return o;
  }),
  (b2Joint.Destroy = function (t, i) {}),
  (b2Joint.e_unknownJoint = 0),
  (b2Joint.e_revoluteJoint = 1),
  (b2Joint.e_prismaticJoint = 2),
  (b2Joint.e_distanceJoint = 3),
  (b2Joint.e_pulleyJoint = 4),
  (b2Joint.e_mouseJoint = 5),
  (b2Joint.e_gearJoint = 6),
  (b2Joint.e_inactiveLimit = 0),
  (b2Joint.e_atLowerLimit = 1),
  (b2Joint.e_atUpperLimit = 2),
  (b2Joint.e_equalLimits = 3);
var b2Jacobian = new b2Root();
jQuery.extend(b2Jacobian.prototype, {
  linear1: new b2Vec2(),
  angular1: null,
  linear2: new b2Vec2(),
  angular2: null,
  SetZero: function () {
    this.linear1.SetZero(),
      (this.angular1 = 0),
      this.linear2.SetZero(),
      (this.angular2 = 0);
  },
  Set: function (t, i, o, n) {
    this.linear1.SetV(t),
      (this.angular1 = i),
      this.linear2.SetV(o),
      (this.angular2 = n);
  },
  Compute: function (t, i, o, n) {
    return (
      this.linear1.x * t.x +
      this.linear1.y * t.y +
      this.angular1 * i +
      (this.linear2.x * o.x + this.linear2.y * o.y) +
      this.angular2 * n
    );
  },
  initialize: function () {
    (this.linear1 = new b2Vec2()), (this.linear2 = new b2Vec2());
  },
});
var b2DistanceJoint = new b2Root();
jQuery.extend(b2DistanceJoint.prototype, b2Joint.prototype),
  jQuery.extend(b2DistanceJoint.prototype, {
    initialize: function (t) {
      (this.m_node1 = new b2JointNode()),
        (this.m_node2 = new b2JointNode()),
        (this.m_type = t.type),
        (this.m_prev = null),
        (this.m_next = null),
        (this.m_body1 = t.body1),
        (this.m_body2 = t.body2),
        (this.m_collideConnected = t.collideConnected),
        (this.m_islandFlag = !1),
        (this.m_userData = t.userData),
        (this.m_localAnchor1 = new b2Vec2()),
        (this.m_localAnchor2 = new b2Vec2()),
        (this.m_u = new b2Vec2());
      var i, o, n;
      (i = this.m_body1.m_R),
        (o = t.anchorPoint1.x - this.m_body1.m_position.x),
        (n = t.anchorPoint1.y - this.m_body1.m_position.y),
        (this.m_localAnchor1.x = o * i.col1.x + n * i.col1.y),
        (this.m_localAnchor1.y = o * i.col2.x + n * i.col2.y),
        (i = this.m_body2.m_R),
        (o = t.anchorPoint2.x - this.m_body2.m_position.x),
        (n = t.anchorPoint2.y - this.m_body2.m_position.y),
        (this.m_localAnchor2.x = o * i.col1.x + n * i.col1.y),
        (this.m_localAnchor2.y = o * i.col2.x + n * i.col2.y),
        (o = t.anchorPoint2.x - t.anchorPoint1.x),
        (n = t.anchorPoint2.y - t.anchorPoint1.y),
        (this.m_length = Math.sqrt(o * o + n * n)),
        (this.m_impulse = 0);
    },
    PrepareVelocitySolver: function () {
      var t;
      t = this.m_body1.m_R;
      var i =
          t.col1.x * this.m_localAnchor1.x + t.col2.x * this.m_localAnchor1.y,
        o = t.col1.y * this.m_localAnchor1.x + t.col2.y * this.m_localAnchor1.y;
      t = this.m_body2.m_R;
      var n =
          t.col1.x * this.m_localAnchor2.x + t.col2.x * this.m_localAnchor2.y,
        e = t.col1.y * this.m_localAnchor2.x + t.col2.y * this.m_localAnchor2.y;
      (this.m_u.x =
        this.m_body2.m_position.x + n - this.m_body1.m_position.x - i),
        (this.m_u.y =
          this.m_body2.m_position.y + e - this.m_body1.m_position.y - o);
      var s = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
      s > b2Settings.b2_linearSlop
        ? this.m_u.Multiply(1 / s)
        : this.m_u.SetZero();
      var a = i * this.m_u.y - o * this.m_u.x,
        l = n * this.m_u.y - e * this.m_u.x;
      if (
        ((this.m_mass =
          this.m_body1.m_invMass +
          this.m_body1.m_invI * a * a +
          this.m_body2.m_invMass +
          this.m_body2.m_invI * l * l),
        (this.m_mass = 1 / this.m_mass),
        b2World.s_enableWarmStarting)
      ) {
        var r = this.m_impulse * this.m_u.x,
          m = this.m_impulse * this.m_u.y;
        (this.m_body1.m_linearVelocity.x -= this.m_body1.m_invMass * r),
          (this.m_body1.m_linearVelocity.y -= this.m_body1.m_invMass * m),
          (this.m_body1.m_angularVelocity -=
            this.m_body1.m_invI * (i * m - o * r)),
          (this.m_body2.m_linearVelocity.x += this.m_body2.m_invMass * r),
          (this.m_body2.m_linearVelocity.y += this.m_body2.m_invMass * m),
          (this.m_body2.m_angularVelocity +=
            this.m_body2.m_invI * (n * m - e * r));
      } else this.m_impulse = 0;
    },
    SolveVelocityConstraints: function (t) {
      var i;
      i = this.m_body1.m_R;
      var o =
          i.col1.x * this.m_localAnchor1.x + i.col2.x * this.m_localAnchor1.y,
        n = i.col1.y * this.m_localAnchor1.x + i.col2.y * this.m_localAnchor1.y;
      i = this.m_body2.m_R;
      var e =
          i.col1.x * this.m_localAnchor2.x + i.col2.x * this.m_localAnchor2.y,
        s = i.col1.y * this.m_localAnchor2.x + i.col2.y * this.m_localAnchor2.y,
        a =
          this.m_body1.m_linearVelocity.x + -this.m_body1.m_angularVelocity * n,
        l =
          this.m_body1.m_linearVelocity.y + this.m_body1.m_angularVelocity * o,
        r =
          this.m_body2.m_linearVelocity.x + -this.m_body2.m_angularVelocity * s,
        m =
          this.m_body2.m_linearVelocity.y + this.m_body2.m_angularVelocity * e,
        _ = this.m_u.x * (r - a) + this.m_u.y * (m - l),
        h = -this.m_mass * _;
      this.m_impulse += h;
      var c = h * this.m_u.x,
        u = h * this.m_u.y;
      (this.m_body1.m_linearVelocity.x -= this.m_body1.m_invMass * c),
        (this.m_body1.m_linearVelocity.y -= this.m_body1.m_invMass * u),
        (this.m_body1.m_angularVelocity -=
          this.m_body1.m_invI * (o * u - n * c)),
        (this.m_body2.m_linearVelocity.x += this.m_body2.m_invMass * c),
        (this.m_body2.m_linearVelocity.y += this.m_body2.m_invMass * u),
        (this.m_body2.m_angularVelocity +=
          this.m_body2.m_invI * (e * u - s * c));
    },
    SolvePositionConstraints: function () {
      var t;
      t = this.m_body1.m_R;
      var i =
          t.col1.x * this.m_localAnchor1.x + t.col2.x * this.m_localAnchor1.y,
        o = t.col1.y * this.m_localAnchor1.x + t.col2.y * this.m_localAnchor1.y;
      t = this.m_body2.m_R;
      var n =
          t.col1.x * this.m_localAnchor2.x + t.col2.x * this.m_localAnchor2.y,
        e = t.col1.y * this.m_localAnchor2.x + t.col2.y * this.m_localAnchor2.y,
        s = this.m_body2.m_position.x + n - this.m_body1.m_position.x - i,
        a = this.m_body2.m_position.y + e - this.m_body1.m_position.y - o,
        l = Math.sqrt(s * s + a * a);
      (s /= l), (a /= l);
      var r = l - this.m_length;
      r = b2Math.b2Clamp(
        r,
        -b2Settings.b2_maxLinearCorrection,
        b2Settings.b2_maxLinearCorrection
      );
      var m = -this.m_mass * r;
      this.m_u.Set(s, a);
      var _ = m * this.m_u.x,
        h = m * this.m_u.y;
      return (
        (this.m_body1.m_position.x -= this.m_body1.m_invMass * _),
        (this.m_body1.m_position.y -= this.m_body1.m_invMass * h),
        (this.m_body1.m_rotation -= this.m_body1.m_invI * (i * h - o * _)),
        (this.m_body2.m_position.x += this.m_body2.m_invMass * _),
        (this.m_body2.m_position.y += this.m_body2.m_invMass * h),
        (this.m_body2.m_rotation += this.m_body2.m_invI * (n * h - e * _)),
        this.m_body1.m_R.Set(this.m_body1.m_rotation),
        this.m_body2.m_R.Set(this.m_body2.m_rotation),
        b2Math.b2Abs(r) < b2Settings.b2_linearSlop
      );
    },
    GetAnchor1: function () {
      return b2Math.AddVV(
        this.m_body1.m_position,
        b2Math.b2MulMV(this.m_body1.m_R, this.m_localAnchor1)
      );
    },
    GetAnchor2: function () {
      return b2Math.AddVV(
        this.m_body2.m_position,
        b2Math.b2MulMV(this.m_body2.m_R, this.m_localAnchor2)
      );
    },
    GetReactionForce: function (t) {
      var i = new b2Vec2();
      return i.SetV(this.m_u), i.Multiply(this.m_impulse * t), i;
    },
    GetReactionTorque: function (t) {
      return 0;
    },
    m_localAnchor1: new b2Vec2(),
    m_localAnchor2: new b2Vec2(),
    m_u: new b2Vec2(),
    m_impulse: null,
    m_mass: null,
    m_length: null,
  });
var b2DistanceJointDef = new b2Root();
jQuery.extend(b2DistanceJointDef.prototype, b2JointDef.prototype),
  jQuery.extend(b2DistanceJointDef.prototype, {
    initialize: function () {
      (this.type = b2Joint.e_unknownJoint),
        (this.userData = null),
        (this.body1 = null),
        (this.body2 = null),
        (this.collideConnected = !1),
        (this.anchorPoint1 = new b2Vec2()),
        (this.anchorPoint2 = new b2Vec2()),
        (this.type = b2Joint.e_distanceJoint);
    },
    anchorPoint1: new b2Vec2(),
    anchorPoint2: new b2Vec2(),
  });
var b2GearJoint = new b2Root();
jQuery.extend(b2GearJoint.prototype, b2Joint.prototype),
  jQuery.extend(b2GearJoint.prototype, {
    GetAnchor1: function () {
      var t = this.m_body1.m_R;
      return new b2Vec2(
        this.m_body1.m_position.x +
          (t.col1.x * this.m_localAnchor1.x + t.col2.x * this.m_localAnchor1.y),
        this.m_body1.m_position.y +
          (t.col1.y * this.m_localAnchor1.x + t.col2.y * this.m_localAnchor1.y)
      );
    },
    GetAnchor2: function () {
      var t = this.m_body2.m_R;
      return new b2Vec2(
        this.m_body2.m_position.x +
          (t.col1.x * this.m_localAnchor2.x + t.col2.x * this.m_localAnchor2.y),
        this.m_body2.m_position.y +
          (t.col1.y * this.m_localAnchor2.x + t.col2.y * this.m_localAnchor2.y)
      );
    },
    GetReactionForce: function (t) {
      return new b2Vec2();
    },
    GetReactionTorque: function (t) {
      return 0;
    },
    GetRatio: function () {
      return this.m_ratio;
    },
    initialize: function (t) {
      (this.m_node1 = new b2JointNode()),
        (this.m_node2 = new b2JointNode()),
        (this.m_type = t.type),
        (this.m_prev = null),
        (this.m_next = null),
        (this.m_body1 = t.body1),
        (this.m_body2 = t.body2),
        (this.m_collideConnected = t.collideConnected),
        (this.m_islandFlag = !1),
        (this.m_userData = t.userData),
        (this.m_groundAnchor1 = new b2Vec2()),
        (this.m_groundAnchor2 = new b2Vec2()),
        (this.m_localAnchor1 = new b2Vec2()),
        (this.m_localAnchor2 = new b2Vec2()),
        (this.m_J = new b2Jacobian()),
        (this.m_revolute1 = null),
        (this.m_prismatic1 = null),
        (this.m_revolute2 = null),
        (this.m_prismatic2 = null);
      var i, o;
      (this.m_ground1 = t.joint1.m_body1),
        (this.m_body1 = t.joint1.m_body2),
        t.joint1.m_type == b2Joint.e_revoluteJoint
          ? ((this.m_revolute1 = t.joint1),
            this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1),
            this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2),
            (i = this.m_revolute1.GetJointAngle()))
          : ((this.m_prismatic1 = t.joint1),
            this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1),
            this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2),
            (i = this.m_prismatic1.GetJointTranslation())),
        (this.m_ground2 = t.joint2.m_body1),
        (this.m_body2 = t.joint2.m_body2),
        t.joint2.m_type == b2Joint.e_revoluteJoint
          ? ((this.m_revolute2 = t.joint2),
            this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1),
            this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2),
            (o = this.m_revolute2.GetJointAngle()))
          : ((this.m_prismatic2 = t.joint2),
            this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1),
            this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2),
            (o = this.m_prismatic2.GetJointTranslation())),
        (this.m_ratio = t.ratio),
        (this.m_constant = i + this.m_ratio * o),
        (this.m_impulse = 0);
    },
    PrepareVelocitySolver: function () {
      var t,
        i,
        o,
        n,
        e,
        s,
        a,
        l = this.m_ground1,
        r = this.m_ground2,
        m = this.m_body1,
        _ = this.m_body2,
        h = 0;
      this.m_J.SetZero(),
        this.m_revolute1
          ? ((this.m_J.angular1 = -1), (h += m.m_invI))
          : ((e = l.m_R),
            (s = this.m_prismatic1.m_localXAxis1),
            (t = e.col1.x * s.x + e.col2.x * s.y),
            (i = e.col1.y * s.x + e.col2.y * s.y),
            (e = m.m_R),
            (o =
              e.col1.x * this.m_localAnchor1.x +
              e.col2.x * this.m_localAnchor1.y),
            (n =
              e.col1.y * this.m_localAnchor1.x +
              e.col2.y * this.m_localAnchor1.y),
            (a = o * i - n * t),
            this.m_J.linear1.Set(-t, -i),
            (this.m_J.angular1 = -a),
            (h += m.m_invMass + m.m_invI * a * a)),
        this.m_revolute2
          ? ((this.m_J.angular2 = -this.m_ratio),
            (h += this.m_ratio * this.m_ratio * _.m_invI))
          : ((e = r.m_R),
            (s = this.m_prismatic2.m_localXAxis1),
            (t = e.col1.x * s.x + e.col2.x * s.y),
            (i = e.col1.y * s.x + e.col2.y * s.y),
            (e = _.m_R),
            (o =
              e.col1.x * this.m_localAnchor2.x +
              e.col2.x * this.m_localAnchor2.y),
            (n =
              e.col1.y * this.m_localAnchor2.x +
              e.col2.y * this.m_localAnchor2.y),
            (a = o * i - n * t),
            this.m_J.linear2.Set(-this.m_ratio * t, -this.m_ratio * i),
            (this.m_J.angular2 = -this.m_ratio * a),
            (h +=
              this.m_ratio * this.m_ratio * (_.m_invMass + _.m_invI * a * a))),
        (this.m_mass = 1 / h),
        (m.m_linearVelocity.x +=
          m.m_invMass * this.m_impulse * this.m_J.linear1.x),
        (m.m_linearVelocity.y +=
          m.m_invMass * this.m_impulse * this.m_J.linear1.y),
        (m.m_angularVelocity += m.m_invI * this.m_impulse * this.m_J.angular1),
        (_.m_linearVelocity.x +=
          _.m_invMass * this.m_impulse * this.m_J.linear2.x),
        (_.m_linearVelocity.y +=
          _.m_invMass * this.m_impulse * this.m_J.linear2.y),
        (_.m_angularVelocity += _.m_invI * this.m_impulse * this.m_J.angular2);
    },
    SolveVelocityConstraints: function (t) {
      var i = this.m_body1,
        o = this.m_body2,
        n = this.m_J.Compute(
          i.m_linearVelocity,
          i.m_angularVelocity,
          o.m_linearVelocity,
          o.m_angularVelocity
        ),
        e = -this.m_mass * n;
      (this.m_impulse += e),
        (i.m_linearVelocity.x += i.m_invMass * e * this.m_J.linear1.x),
        (i.m_linearVelocity.y += i.m_invMass * e * this.m_J.linear1.y),
        (i.m_angularVelocity += i.m_invI * e * this.m_J.angular1),
        (o.m_linearVelocity.x += o.m_invMass * e * this.m_J.linear2.x),
        (o.m_linearVelocity.y += o.m_invMass * e * this.m_J.linear2.y),
        (o.m_angularVelocity += o.m_invI * e * this.m_J.angular2);
    },
    SolvePositionConstraints: function () {
      var t,
        i,
        o = 0,
        n = this.m_body1,
        e = this.m_body2;
      (t = this.m_revolute1
        ? this.m_revolute1.GetJointAngle()
        : this.m_prismatic1.GetJointTranslation()),
        (i = this.m_revolute2
          ? this.m_revolute2.GetJointAngle()
          : this.m_prismatic2.GetJointTranslation());
      var s = this.m_constant - (t + this.m_ratio * i),
        a = -this.m_mass * s;
      return (
        (n.m_position.x += n.m_invMass * a * this.m_J.linear1.x),
        (n.m_position.y += n.m_invMass * a * this.m_J.linear1.y),
        (n.m_rotation += n.m_invI * a * this.m_J.angular1),
        (e.m_position.x += e.m_invMass * a * this.m_J.linear2.x),
        (e.m_position.y += e.m_invMass * a * this.m_J.linear2.y),
        (e.m_rotation += e.m_invI * a * this.m_J.angular2),
        n.m_R.Set(n.m_rotation),
        e.m_R.Set(e.m_rotation),
        o < b2Settings.b2_linearSlop
      );
    },
    m_ground1: null,
    m_ground2: null,
    m_revolute1: null,
    m_prismatic1: null,
    m_revolute2: null,
    m_prismatic2: null,
    m_groundAnchor1: new b2Vec2(),
    m_groundAnchor2: new b2Vec2(),
    m_localAnchor1: new b2Vec2(),
    m_localAnchor2: new b2Vec2(),
    m_J: new b2Jacobian(),
    m_constant: null,
    m_ratio: null,
    m_mass: null,
    m_impulse: null,
  });
var b2GearJointDef = new b2Root();
jQuery.extend(b2GearJointDef.prototype, b2JointDef.prototype),
  jQuery.extend(b2GearJointDef.prototype, {
    initialize: function () {
      (this.type = b2Joint.e_gearJoint),
        (this.joint1 = null),
        (this.joint2 = null),
        (this.ratio = 1);
    },
    joint1: null,
    joint2: null,
    ratio: null,
  });
var b2MouseJoint = new b2Root();
jQuery.extend(b2MouseJoint.prototype, b2Joint.prototype),
  jQuery.extend(b2MouseJoint.prototype, {
    GetAnchor1: function () {
      return this.m_target;
    },
    GetAnchor2: function () {
      var t = b2Math.b2MulMV(this.m_body2.m_R, this.m_localAnchor);
      return t.Add(this.m_body2.m_position), t;
    },
    GetReactionForce: function (t) {
      var i = new b2Vec2();
      return i.SetV(this.m_impulse), i.Multiply(t), i;
    },
    GetReactionTorque: function (t) {
      return 0;
    },
    SetTarget: function (t) {
      this.m_body2.WakeUp(), (this.m_target = t);
    },
    initialize: function (t) {
      (this.m_node1 = new b2JointNode()),
        (this.m_node2 = new b2JointNode()),
        (this.m_type = t.type),
        (this.m_prev = null),
        (this.m_next = null),
        (this.m_body1 = t.body1),
        (this.m_body2 = t.body2),
        (this.m_collideConnected = t.collideConnected),
        (this.m_islandFlag = !1),
        (this.m_userData = t.userData),
        (this.K = new b2Mat22()),
        (this.K1 = new b2Mat22()),
        (this.K2 = new b2Mat22()),
        (this.m_localAnchor = new b2Vec2()),
        (this.m_target = new b2Vec2()),
        (this.m_impulse = new b2Vec2()),
        (this.m_ptpMass = new b2Mat22()),
        (this.m_C = new b2Vec2()),
        this.m_target.SetV(t.target);
      var i = this.m_target.x - this.m_body2.m_position.x,
        o = this.m_target.y - this.m_body2.m_position.y;
      (this.m_localAnchor.x =
        i * this.m_body2.m_R.col1.x + o * this.m_body2.m_R.col1.y),
        (this.m_localAnchor.y =
          i * this.m_body2.m_R.col2.x + o * this.m_body2.m_R.col2.y),
        (this.m_maxForce = t.maxForce),
        this.m_impulse.SetZero();
      var n = this.m_body2.m_mass,
        e = 2 * b2Settings.b2_pi * t.frequencyHz,
        s = 2 * n * t.dampingRatio * e,
        a = n * e * e;
      (this.m_gamma = 1 / (s + t.timeStep * a)),
        (this.m_beta = (t.timeStep * a) / (s + t.timeStep * a));
    },
    K: new b2Mat22(),
    K1: new b2Mat22(),
    K2: new b2Mat22(),
    PrepareVelocitySolver: function () {
      var t,
        i = this.m_body2;
      t = i.m_R;
      var o = t.col1.x * this.m_localAnchor.x + t.col2.x * this.m_localAnchor.y,
        n = t.col1.y * this.m_localAnchor.x + t.col2.y * this.m_localAnchor.y,
        e = i.m_invMass,
        s = i.m_invI;
      (this.K1.col1.x = e),
        (this.K1.col2.x = 0),
        (this.K1.col1.y = 0),
        (this.K1.col2.y = e),
        (this.K2.col1.x = s * n * n),
        (this.K2.col2.x = -s * o * n),
        (this.K2.col1.y = -s * o * n),
        (this.K2.col2.y = s * o * o),
        this.K.SetM(this.K1),
        this.K.AddM(this.K2),
        (this.K.col1.x += this.m_gamma),
        (this.K.col2.y += this.m_gamma),
        this.K.Invert(this.m_ptpMass),
        (this.m_C.x = i.m_position.x + o - this.m_target.x),
        (this.m_C.y = i.m_position.y + n - this.m_target.y),
        (i.m_angularVelocity *= 0.98);
      var a = this.m_impulse.x,
        l = this.m_impulse.y;
      (i.m_linearVelocity.x += e * a),
        (i.m_linearVelocity.y += e * l),
        (i.m_angularVelocity += s * (o * l - n * a));
    },
    SolveVelocityConstraints: function (t) {
      var i,
        o = this.m_body2;
      i = o.m_R;
      var n = i.col1.x * this.m_localAnchor.x + i.col2.x * this.m_localAnchor.y,
        e = i.col1.y * this.m_localAnchor.x + i.col2.y * this.m_localAnchor.y,
        s = o.m_linearVelocity.x + -o.m_angularVelocity * e,
        a = o.m_linearVelocity.y + o.m_angularVelocity * n;
      i = this.m_ptpMass;
      var l =
          s +
          this.m_beta * t.inv_dt * this.m_C.x +
          this.m_gamma * this.m_impulse.x,
        r =
          a +
          this.m_beta * t.inv_dt * this.m_C.y +
          this.m_gamma * this.m_impulse.y,
        m = -(i.col1.x * l + i.col2.x * r),
        _ = -(i.col1.y * l + i.col2.y * r),
        h = this.m_impulse.x,
        c = this.m_impulse.y;
      (this.m_impulse.x += m), (this.m_impulse.y += _);
      var u = this.m_impulse.Length();
      u > t.dt * this.m_maxForce &&
        this.m_impulse.Multiply((t.dt * this.m_maxForce) / u),
        (m = this.m_impulse.x - h),
        (_ = this.m_impulse.y - c),
        (o.m_linearVelocity.x += o.m_invMass * m),
        (o.m_linearVelocity.y += o.m_invMass * _),
        (o.m_angularVelocity += o.m_invI * (n * _ - e * m));
    },
    SolvePositionConstraints: function () {
      return !0;
    },
    m_localAnchor: new b2Vec2(),
    m_target: new b2Vec2(),
    m_impulse: new b2Vec2(),
    m_ptpMass: new b2Mat22(),
    m_C: new b2Vec2(),
    m_maxForce: null,
    m_beta: null,
    m_gamma: null,
  });
var b2MouseJointDef = new b2Root();
jQuery.extend(b2MouseJointDef.prototype, b2JointDef.prototype),
  jQuery.extend(b2MouseJointDef.prototype, {
    initialize: function () {
      (this.type = b2Joint.e_unknownJoint),
        (this.userData = null),
        (this.body1 = null),
        (this.body2 = null),
        (this.collideConnected = !1),
        (this.target = new b2Vec2()),
        (this.type = b2Joint.e_mouseJoint),
        (this.maxForce = 0),
        (this.frequencyHz = 5),
        (this.dampingRatio = 0.7),
        (this.timeStep = 1 / 60);
    },
    target: new b2Vec2(),
    maxForce: null,
    frequencyHz: null,
    dampingRatio: null,
    timeStep: null,
  });
var b2PrismaticJoint = new b2Root();
jQuery.extend(b2PrismaticJoint.prototype, b2Joint.prototype),
  jQuery.extend(b2PrismaticJoint.prototype, {
    GetAnchor1: function () {
      var t = this.m_body1,
        i = new b2Vec2();
      return i.SetV(this.m_localAnchor1), i.MulM(t.m_R), i.Add(t.m_position), i;
    },
    GetAnchor2: function () {
      var t = this.m_body2,
        i = new b2Vec2();
      return i.SetV(this.m_localAnchor2), i.MulM(t.m_R), i.Add(t.m_position), i;
    },
    GetJointTranslation: function () {
      var t,
        i = this.m_body1,
        o = this.m_body2;
      t = i.m_R;
      var n =
          t.col1.x * this.m_localAnchor1.x + t.col2.x * this.m_localAnchor1.y,
        e = t.col1.y * this.m_localAnchor1.x + t.col2.y * this.m_localAnchor1.y;
      t = o.m_R;
      var s =
          t.col1.x * this.m_localAnchor2.x + t.col2.x * this.m_localAnchor2.y,
        a = t.col1.y * this.m_localAnchor2.x + t.col2.y * this.m_localAnchor2.y,
        l = i.m_position.x + n,
        r = i.m_position.y + e,
        m = o.m_position.x + s,
        _ = o.m_position.y + a,
        h = m - l,
        c = _ - r;
      t = i.m_R;
      var u = t.col1.x * this.m_localXAxis1.x + t.col2.x * this.m_localXAxis1.y,
        y = t.col1.y * this.m_localXAxis1.x + t.col2.y * this.m_localXAxis1.y,
        b = u * h + y * c;
      return b;
    },
    GetJointSpeed: function () {
      var t,
        i = this.m_body1,
        o = this.m_body2;
      t = i.m_R;
      var n =
          t.col1.x * this.m_localAnchor1.x + t.col2.x * this.m_localAnchor1.y,
        e = t.col1.y * this.m_localAnchor1.x + t.col2.y * this.m_localAnchor1.y;
      t = o.m_R;
      var s =
          t.col1.x * this.m_localAnchor2.x + t.col2.x * this.m_localAnchor2.y,
        a = t.col1.y * this.m_localAnchor2.x + t.col2.y * this.m_localAnchor2.y,
        l = i.m_position.x + n,
        r = i.m_position.y + e,
        m = o.m_position.x + s,
        _ = o.m_position.y + a,
        h = m - l,
        c = _ - r;
      t = i.m_R;
      var u = t.col1.x * this.m_localXAxis1.x + t.col2.x * this.m_localXAxis1.y,
        y = t.col1.y * this.m_localXAxis1.x + t.col2.y * this.m_localXAxis1.y,
        b = i.m_linearVelocity,
        p = o.m_linearVelocity,
        x = i.m_angularVelocity,
        d = o.m_angularVelocity,
        v =
          h * -x * y +
          c * x * u +
          (u * (p.x + -d * a - b.x - -x * e) + y * (p.y + d * s - b.y - x * n));
      return v;
    },
    GetMotorForce: function (t) {
      return t * this.m_motorImpulse;
    },
    SetMotorSpeed: function (t) {
      this.m_motorSpeed = t;
    },
    SetMotorForce: function (t) {
      this.m_maxMotorForce = t;
    },
    GetReactionForce: function (t) {
      var i,
        o = t * this.m_limitImpulse;
      i = this.m_body1.m_R;
      var n =
          o *
          (i.col1.x * this.m_localXAxis1.x + i.col2.x * this.m_localXAxis1.y),
        e =
          o *
          (i.col1.y * this.m_localXAxis1.x + i.col2.y * this.m_localXAxis1.y),
        s =
          o *
          (i.col1.x * this.m_localYAxis1.x + i.col2.x * this.m_localYAxis1.y),
        a =
          o *
          (i.col1.y * this.m_localYAxis1.x + i.col2.y * this.m_localYAxis1.y);
      return new b2Vec2(n + s, e + a);
    },
    GetReactionTorque: function (t) {
      return t * this.m_angularImpulse;
    },
    initialize: function (t) {
      (this.m_node1 = new b2JointNode()),
        (this.m_node2 = new b2JointNode()),
        (this.m_type = t.type),
        (this.m_prev = null),
        (this.m_next = null),
        (this.m_body1 = t.body1),
        (this.m_body2 = t.body2),
        (this.m_collideConnected = t.collideConnected),
        (this.m_islandFlag = !1),
        (this.m_userData = t.userData),
        (this.m_localAnchor1 = new b2Vec2()),
        (this.m_localAnchor2 = new b2Vec2()),
        (this.m_localXAxis1 = new b2Vec2()),
        (this.m_localYAxis1 = new b2Vec2()),
        (this.m_linearJacobian = new b2Jacobian()),
        (this.m_motorJacobian = new b2Jacobian());
      var i, o, n;
      (i = this.m_body1.m_R),
        (o = t.anchorPoint.x - this.m_body1.m_position.x),
        (n = t.anchorPoint.y - this.m_body1.m_position.y),
        this.m_localAnchor1.Set(
          o * i.col1.x + n * i.col1.y,
          o * i.col2.x + n * i.col2.y
        ),
        (i = this.m_body2.m_R),
        (o = t.anchorPoint.x - this.m_body2.m_position.x),
        (n = t.anchorPoint.y - this.m_body2.m_position.y),
        this.m_localAnchor2.Set(
          o * i.col1.x + n * i.col1.y,
          o * i.col2.x + n * i.col2.y
        ),
        (i = this.m_body1.m_R),
        (o = t.axis.x),
        (n = t.axis.y),
        this.m_localXAxis1.Set(
          o * i.col1.x + n * i.col1.y,
          o * i.col2.x + n * i.col2.y
        ),
        (this.m_localYAxis1.x = -this.m_localXAxis1.y),
        (this.m_localYAxis1.y = this.m_localXAxis1.x),
        (this.m_initialAngle =
          this.m_body2.m_rotation - this.m_body1.m_rotation),
        this.m_linearJacobian.SetZero(),
        (this.m_linearMass = 0),
        (this.m_linearImpulse = 0),
        (this.m_angularMass = 0),
        (this.m_angularImpulse = 0),
        this.m_motorJacobian.SetZero(),
        (this.m_motorMass = 0),
        (this.m_motorImpulse = 0),
        (this.m_limitImpulse = 0),
        (this.m_limitPositionImpulse = 0),
        (this.m_lowerTranslation = t.lowerTranslation),
        (this.m_upperTranslation = t.upperTranslation),
        (this.m_maxMotorForce = t.motorForce),
        (this.m_motorSpeed = t.motorSpeed),
        (this.m_enableLimit = t.enableLimit),
        (this.m_enableMotor = t.enableMotor);
    },
    PrepareVelocitySolver: function () {
      var t,
        i = this.m_body1,
        o = this.m_body2;
      t = i.m_R;
      var n =
          t.col1.x * this.m_localAnchor1.x + t.col2.x * this.m_localAnchor1.y,
        e = t.col1.y * this.m_localAnchor1.x + t.col2.y * this.m_localAnchor1.y;
      t = o.m_R;
      var s =
          t.col1.x * this.m_localAnchor2.x + t.col2.x * this.m_localAnchor2.y,
        a = t.col1.y * this.m_localAnchor2.x + t.col2.y * this.m_localAnchor2.y,
        l = i.m_invMass,
        r = o.m_invMass,
        m = i.m_invI,
        _ = o.m_invI;
      t = i.m_R;
      var h = t.col1.x * this.m_localYAxis1.x + t.col2.x * this.m_localYAxis1.y,
        c = t.col1.y * this.m_localYAxis1.x + t.col2.y * this.m_localYAxis1.y,
        u = o.m_position.x + s - i.m_position.x,
        y = o.m_position.y + a - i.m_position.y;
      if (
        ((this.m_linearJacobian.linear1.x = -h),
        (this.m_linearJacobian.linear1.y = -c),
        (this.m_linearJacobian.linear2.x = h),
        (this.m_linearJacobian.linear2.y = c),
        (this.m_linearJacobian.angular1 = -(u * c - y * h)),
        (this.m_linearJacobian.angular2 = s * c - a * h),
        (this.m_linearMass =
          l +
          m * this.m_linearJacobian.angular1 * this.m_linearJacobian.angular1 +
          r +
          _ * this.m_linearJacobian.angular2 * this.m_linearJacobian.angular2),
        (this.m_linearMass = 1 / this.m_linearMass),
        (this.m_angularMass = 1 / (m + _)),
        this.m_enableLimit || this.m_enableMotor)
      ) {
        t = i.m_R;
        var b =
            t.col1.x * this.m_localXAxis1.x + t.col2.x * this.m_localXAxis1.y,
          p = t.col1.y * this.m_localXAxis1.x + t.col2.y * this.m_localXAxis1.y;
        if (
          ((this.m_motorJacobian.linear1.x = -b),
          (this.m_motorJacobian.linear1.y = -p),
          (this.m_motorJacobian.linear2.x = b),
          (this.m_motorJacobian.linear2.y = p),
          (this.m_motorJacobian.angular1 = -(u * p - y * b)),
          (this.m_motorJacobian.angular2 = s * p - a * b),
          (this.m_motorMass =
            l +
            m * this.m_motorJacobian.angular1 * this.m_motorJacobian.angular1 +
            r +
            _ * this.m_motorJacobian.angular2 * this.m_motorJacobian.angular2),
          (this.m_motorMass = 1 / this.m_motorMass),
          this.m_enableLimit)
        ) {
          var x = u - n,
            d = y - e,
            v = b * x + p * d;
          b2Math.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) <
          2 * b2Settings.b2_linearSlop
            ? (this.m_limitState = b2Joint.e_equalLimits)
            : v <= this.m_lowerTranslation
            ? (this.m_limitState != b2Joint.e_atLowerLimit &&
                (this.m_limitImpulse = 0),
              (this.m_limitState = b2Joint.e_atLowerLimit))
            : v >= this.m_upperTranslation
            ? (this.m_limitState != b2Joint.e_atUpperLimit &&
                (this.m_limitImpulse = 0),
              (this.m_limitState = b2Joint.e_atUpperLimit))
            : ((this.m_limitState = b2Joint.e_inactiveLimit),
              (this.m_limitImpulse = 0));
        }
      }
      if (
        (0 == this.m_enableMotor && (this.m_motorImpulse = 0),
        0 == this.m_enableLimit && (this.m_limitImpulse = 0),
        b2World.s_enableWarmStarting)
      ) {
        var f =
            this.m_linearImpulse * this.m_linearJacobian.linear1.x +
            (this.m_motorImpulse + this.m_limitImpulse) *
              this.m_motorJacobian.linear1.x,
          g =
            this.m_linearImpulse * this.m_linearJacobian.linear1.y +
            (this.m_motorImpulse + this.m_limitImpulse) *
              this.m_motorJacobian.linear1.y,
          M =
            this.m_linearImpulse * this.m_linearJacobian.linear2.x +
            (this.m_motorImpulse + this.m_limitImpulse) *
              this.m_motorJacobian.linear2.x,
          V =
            this.m_linearImpulse * this.m_linearJacobian.linear2.y +
            (this.m_motorImpulse + this.m_limitImpulse) *
              this.m_motorJacobian.linear2.y,
          S =
            this.m_linearImpulse * this.m_linearJacobian.angular1 -
            this.m_angularImpulse +
            (this.m_motorImpulse + this.m_limitImpulse) *
              this.m_motorJacobian.angular1,
          C =
            this.m_linearImpulse * this.m_linearJacobian.angular2 +
            this.m_angularImpulse +
            (this.m_motorImpulse + this.m_limitImpulse) *
              this.m_motorJacobian.angular2;
        (i.m_linearVelocity.x += l * f),
          (i.m_linearVelocity.y += l * g),
          (i.m_angularVelocity += m * S),
          (o.m_linearVelocity.x += r * M),
          (o.m_linearVelocity.y += r * V),
          (o.m_angularVelocity += _ * C);
      } else
        (this.m_linearImpulse = 0),
          (this.m_angularImpulse = 0),
          (this.m_limitImpulse = 0),
          (this.m_motorImpulse = 0);
      this.m_limitPositionImpulse = 0;
    },
    SolveVelocityConstraints: function (t) {
      var i,
        o = this.m_body1,
        n = this.m_body2,
        e = o.m_invMass,
        s = n.m_invMass,
        a = o.m_invI,
        l = n.m_invI,
        r = this.m_linearJacobian.Compute(
          o.m_linearVelocity,
          o.m_angularVelocity,
          n.m_linearVelocity,
          n.m_angularVelocity
        ),
        m = -this.m_linearMass * r;
      (this.m_linearImpulse += m),
        (o.m_linearVelocity.x += e * m * this.m_linearJacobian.linear1.x),
        (o.m_linearVelocity.y += e * m * this.m_linearJacobian.linear1.y),
        (o.m_angularVelocity += a * m * this.m_linearJacobian.angular1),
        (n.m_linearVelocity.x += s * m * this.m_linearJacobian.linear2.x),
        (n.m_linearVelocity.y += s * m * this.m_linearJacobian.linear2.y),
        (n.m_angularVelocity += l * m * this.m_linearJacobian.angular2);
      var _ = n.m_angularVelocity - o.m_angularVelocity,
        h = -this.m_angularMass * _;
      if (
        ((this.m_angularImpulse += h),
        (o.m_angularVelocity -= a * h),
        (n.m_angularVelocity += l * h),
        this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits)
      ) {
        var c =
            this.m_motorJacobian.Compute(
              o.m_linearVelocity,
              o.m_angularVelocity,
              n.m_linearVelocity,
              n.m_angularVelocity
            ) - this.m_motorSpeed,
          u = -this.m_motorMass * c,
          y = this.m_motorImpulse;
        (this.m_motorImpulse = b2Math.b2Clamp(
          this.m_motorImpulse + u,
          -t.dt * this.m_maxMotorForce,
          t.dt * this.m_maxMotorForce
        )),
          (u = this.m_motorImpulse - y),
          (o.m_linearVelocity.x += e * u * this.m_motorJacobian.linear1.x),
          (o.m_linearVelocity.y += e * u * this.m_motorJacobian.linear1.y),
          (o.m_angularVelocity += a * u * this.m_motorJacobian.angular1),
          (n.m_linearVelocity.x += s * u * this.m_motorJacobian.linear2.x),
          (n.m_linearVelocity.y += s * u * this.m_motorJacobian.linear2.y),
          (n.m_angularVelocity += l * u * this.m_motorJacobian.angular2);
      }
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
        var b = this.m_motorJacobian.Compute(
            o.m_linearVelocity,
            o.m_angularVelocity,
            n.m_linearVelocity,
            n.m_angularVelocity
          ),
          p = -this.m_motorMass * b;
        this.m_limitState == b2Joint.e_equalLimits
          ? (this.m_limitImpulse += p)
          : this.m_limitState == b2Joint.e_atLowerLimit
          ? ((i = this.m_limitImpulse),
            (this.m_limitImpulse = b2Math.b2Max(this.m_limitImpulse + p, 0)),
            (p = this.m_limitImpulse - i))
          : this.m_limitState == b2Joint.e_atUpperLimit &&
            ((i = this.m_limitImpulse),
            (this.m_limitImpulse = b2Math.b2Min(this.m_limitImpulse + p, 0)),
            (p = this.m_limitImpulse - i)),
          (o.m_linearVelocity.x += e * p * this.m_motorJacobian.linear1.x),
          (o.m_linearVelocity.y += e * p * this.m_motorJacobian.linear1.y),
          (o.m_angularVelocity += a * p * this.m_motorJacobian.angular1),
          (n.m_linearVelocity.x += s * p * this.m_motorJacobian.linear2.x),
          (n.m_linearVelocity.y += s * p * this.m_motorJacobian.linear2.y),
          (n.m_angularVelocity += l * p * this.m_motorJacobian.angular2);
      }
    },
    SolvePositionConstraints: function () {
      var t,
        i,
        o,
        n = this.m_body1,
        e = this.m_body2,
        s = n.m_invMass,
        a = e.m_invMass,
        l = n.m_invI,
        r = e.m_invI;
      o = n.m_R;
      var m =
          o.col1.x * this.m_localAnchor1.x + o.col2.x * this.m_localAnchor1.y,
        _ = o.col1.y * this.m_localAnchor1.x + o.col2.y * this.m_localAnchor1.y;
      o = e.m_R;
      var h =
          o.col1.x * this.m_localAnchor2.x + o.col2.x * this.m_localAnchor2.y,
        c = o.col1.y * this.m_localAnchor2.x + o.col2.y * this.m_localAnchor2.y,
        u = n.m_position.x + m,
        y = n.m_position.y + _,
        b = e.m_position.x + h,
        p = e.m_position.y + c,
        x = b - u,
        d = p - y;
      o = n.m_R;
      var v = o.col1.x * this.m_localYAxis1.x + o.col2.x * this.m_localYAxis1.y,
        f = o.col1.y * this.m_localYAxis1.x + o.col2.y * this.m_localYAxis1.y,
        g = v * x + f * d;
      g = b2Math.b2Clamp(
        g,
        -b2Settings.b2_maxLinearCorrection,
        b2Settings.b2_maxLinearCorrection
      );
      var M = -this.m_linearMass * g;
      (n.m_position.x += s * M * this.m_linearJacobian.linear1.x),
        (n.m_position.y += s * M * this.m_linearJacobian.linear1.y),
        (n.m_rotation += l * M * this.m_linearJacobian.angular1),
        (e.m_position.x += a * M * this.m_linearJacobian.linear2.x),
        (e.m_position.y += a * M * this.m_linearJacobian.linear2.y),
        (e.m_rotation += r * M * this.m_linearJacobian.angular2);
      var V = b2Math.b2Abs(g),
        S = e.m_rotation - n.m_rotation - this.m_initialAngle;
      S = b2Math.b2Clamp(
        S,
        -b2Settings.b2_maxAngularCorrection,
        b2Settings.b2_maxAngularCorrection
      );
      var C = -this.m_angularMass * S;
      (n.m_rotation -= n.m_invI * C),
        n.m_R.Set(n.m_rotation),
        (e.m_rotation += e.m_invI * C),
        e.m_R.Set(e.m_rotation);
      var A = b2Math.b2Abs(S);
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
        (o = n.m_R),
          (m =
            o.col1.x * this.m_localAnchor1.x +
            o.col2.x * this.m_localAnchor1.y),
          (_ =
            o.col1.y * this.m_localAnchor1.x +
            o.col2.y * this.m_localAnchor1.y),
          (o = e.m_R),
          (h =
            o.col1.x * this.m_localAnchor2.x +
            o.col2.x * this.m_localAnchor2.y),
          (c =
            o.col1.y * this.m_localAnchor2.x +
            o.col2.y * this.m_localAnchor2.y),
          (u = n.m_position.x + m),
          (y = n.m_position.y + _),
          (b = e.m_position.x + h),
          (p = e.m_position.y + c),
          (x = b - u),
          (d = p - y),
          (o = n.m_R);
        var w =
            o.col1.x * this.m_localXAxis1.x + o.col2.x * this.m_localXAxis1.y,
          P = o.col1.y * this.m_localXAxis1.x + o.col2.y * this.m_localXAxis1.y,
          I = w * x + P * d,
          B = 0;
        this.m_limitState == b2Joint.e_equalLimits
          ? ((t = b2Math.b2Clamp(
              I,
              -b2Settings.b2_maxLinearCorrection,
              b2Settings.b2_maxLinearCorrection
            )),
            (B = -this.m_motorMass * t),
            (V = b2Math.b2Max(V, b2Math.b2Abs(S))))
          : this.m_limitState == b2Joint.e_atLowerLimit
          ? ((t = I - this.m_lowerTranslation),
            (V = b2Math.b2Max(V, -t)),
            (t = b2Math.b2Clamp(
              t + b2Settings.b2_linearSlop,
              -b2Settings.b2_maxLinearCorrection,
              0
            )),
            (B = -this.m_motorMass * t),
            (i = this.m_limitPositionImpulse),
            (this.m_limitPositionImpulse = b2Math.b2Max(
              this.m_limitPositionImpulse + B,
              0
            )),
            (B = this.m_limitPositionImpulse - i))
          : this.m_limitState == b2Joint.e_atUpperLimit &&
            ((t = I - this.m_upperTranslation),
            (V = b2Math.b2Max(V, t)),
            (t = b2Math.b2Clamp(
              t - b2Settings.b2_linearSlop,
              0,
              b2Settings.b2_maxLinearCorrection
            )),
            (B = -this.m_motorMass * t),
            (i = this.m_limitPositionImpulse),
            (this.m_limitPositionImpulse = b2Math.b2Min(
              this.m_limitPositionImpulse + B,
              0
            )),
            (B = this.m_limitPositionImpulse - i)),
          (n.m_position.x += s * B * this.m_motorJacobian.linear1.x),
          (n.m_position.y += s * B * this.m_motorJacobian.linear1.y),
          (n.m_rotation += l * B * this.m_motorJacobian.angular1),
          n.m_R.Set(n.m_rotation),
          (e.m_position.x += a * B * this.m_motorJacobian.linear2.x),
          (e.m_position.y += a * B * this.m_motorJacobian.linear2.y),
          (e.m_rotation += r * B * this.m_motorJacobian.angular2),
          e.m_R.Set(e.m_rotation);
      }
      return V <= b2Settings.b2_linearSlop && A <= b2Settings.b2_angularSlop;
    },
    m_localAnchor1: new b2Vec2(),
    m_localAnchor2: new b2Vec2(),
    m_localXAxis1: new b2Vec2(),
    m_localYAxis1: new b2Vec2(),
    m_initialAngle: null,
    m_linearJacobian: new b2Jacobian(),
    m_linearMass: null,
    m_linearImpulse: null,
    m_angularMass: null,
    m_angularImpulse: null,
    m_motorJacobian: new b2Jacobian(),
    m_motorMass: null,
    m_motorImpulse: null,
    m_limitImpulse: null,
    m_limitPositionImpulse: null,
    m_lowerTranslation: null,
    m_upperTranslation: null,
    m_maxMotorForce: null,
    m_motorSpeed: null,
    m_enableLimit: null,
    m_enableMotor: null,
    m_limitState: 0,
  });
var b2PrismaticJointDef = new b2Root();
jQuery.extend(b2PrismaticJointDef.prototype, b2JointDef.prototype),
  jQuery.extend(b2PrismaticJointDef.prototype, {
    initialize: function () {
      (this.type = b2Joint.e_unknownJoint),
        (this.userData = null),
        (this.body1 = null),
        (this.body2 = null),
        (this.collideConnected = !1),
        (this.type = b2Joint.e_prismaticJoint),
        (this.anchorPoint = new b2Vec2(0, 0)),
        (this.axis = new b2Vec2(0, 0)),
        (this.lowerTranslation = 0),
        (this.upperTranslation = 0),
        (this.motorForce = 0),
        (this.motorSpeed = 0),
        (this.enableLimit = !1),
        (this.enableMotor = !1);
    },
    anchorPoint: null,
    axis: null,
    lowerTranslation: null,
    upperTranslation: null,
    motorForce: null,
    motorSpeed: null,
    enableLimit: null,
    enableMotor: null,
  });
var b2PulleyJoint = new b2Root();
jQuery.extend(b2PulleyJoint.prototype, b2Joint.prototype),
  jQuery.extend(b2PulleyJoint.prototype, {
    GetAnchor1: function () {
      var t = this.m_body1.m_R;
      return new b2Vec2(
        this.m_body1.m_position.x +
          (t.col1.x * this.m_localAnchor1.x + t.col2.x * this.m_localAnchor1.y),
        this.m_body1.m_position.y +
          (t.col1.y * this.m_localAnchor1.x + t.col2.y * this.m_localAnchor1.y)
      );
    },
    GetAnchor2: function () {
      var t = this.m_body2.m_R;
      return new b2Vec2(
        this.m_body2.m_position.x +
          (t.col1.x * this.m_localAnchor2.x + t.col2.x * this.m_localAnchor2.y),
        this.m_body2.m_position.y +
          (t.col1.y * this.m_localAnchor2.x + t.col2.y * this.m_localAnchor2.y)
      );
    },
    GetGroundPoint1: function () {
      return new b2Vec2(
        this.m_ground.m_position.x + this.m_groundAnchor1.x,
        this.m_ground.m_position.y + this.m_groundAnchor1.y
      );
    },
    GetGroundPoint2: function () {
      return new b2Vec2(
        this.m_ground.m_position.x + this.m_groundAnchor2.x,
        this.m_ground.m_position.y + this.m_groundAnchor2.y
      );
    },
    GetReactionForce: function (t) {
      return new b2Vec2();
    },
    GetReactionTorque: function (t) {
      return 0;
    },
    GetLength1: function () {
      var t;
      t = this.m_body1.m_R;
      var i =
          this.m_body1.m_position.x +
          (t.col1.x * this.m_localAnchor1.x + t.col2.x * this.m_localAnchor1.y),
        o =
          this.m_body1.m_position.y +
          (t.col1.y * this.m_localAnchor1.x + t.col2.y * this.m_localAnchor1.y),
        n = i - (this.m_ground.m_position.x + this.m_groundAnchor1.x),
        e = o - (this.m_ground.m_position.y + this.m_groundAnchor1.y);
      return Math.sqrt(n * n + e * e);
    },
    GetLength2: function () {
      var t;
      t = this.m_body2.m_R;
      var i =
          this.m_body2.m_position.x +
          (t.col1.x * this.m_localAnchor2.x + t.col2.x * this.m_localAnchor2.y),
        o =
          this.m_body2.m_position.y +
          (t.col1.y * this.m_localAnchor2.x + t.col2.y * this.m_localAnchor2.y),
        n = i - (this.m_ground.m_position.x + this.m_groundAnchor2.x),
        e = o - (this.m_ground.m_position.y + this.m_groundAnchor2.y);
      return Math.sqrt(n * n + e * e);
    },
    GetRatio: function () {
      return this.m_ratio;
    },
    initialize: function (t) {
      (this.m_node1 = new b2JointNode()),
        (this.m_node2 = new b2JointNode()),
        (this.m_type = t.type),
        (this.m_prev = null),
        (this.m_next = null),
        (this.m_body1 = t.body1),
        (this.m_body2 = t.body2),
        (this.m_collideConnected = t.collideConnected),
        (this.m_islandFlag = !1),
        (this.m_userData = t.userData),
        (this.m_groundAnchor1 = new b2Vec2()),
        (this.m_groundAnchor2 = new b2Vec2()),
        (this.m_localAnchor1 = new b2Vec2()),
        (this.m_localAnchor2 = new b2Vec2()),
        (this.m_u1 = new b2Vec2()),
        (this.m_u2 = new b2Vec2());
      var i, o, n;
      (this.m_ground = this.m_body1.m_world.m_groundBody),
        (this.m_groundAnchor1.x =
          t.groundPoint1.x - this.m_ground.m_position.x),
        (this.m_groundAnchor1.y =
          t.groundPoint1.y - this.m_ground.m_position.y),
        (this.m_groundAnchor2.x =
          t.groundPoint2.x - this.m_ground.m_position.x),
        (this.m_groundAnchor2.y =
          t.groundPoint2.y - this.m_ground.m_position.y),
        (i = this.m_body1.m_R),
        (o = t.anchorPoint1.x - this.m_body1.m_position.x),
        (n = t.anchorPoint1.y - this.m_body1.m_position.y),
        (this.m_localAnchor1.x = o * i.col1.x + n * i.col1.y),
        (this.m_localAnchor1.y = o * i.col2.x + n * i.col2.y),
        (i = this.m_body2.m_R),
        (o = t.anchorPoint2.x - this.m_body2.m_position.x),
        (n = t.anchorPoint2.y - this.m_body2.m_position.y),
        (this.m_localAnchor2.x = o * i.col1.x + n * i.col1.y),
        (this.m_localAnchor2.y = o * i.col2.x + n * i.col2.y),
        (this.m_ratio = t.ratio),
        (o = t.groundPoint1.x - t.anchorPoint1.x),
        (n = t.groundPoint1.y - t.anchorPoint1.y);
      var e = Math.sqrt(o * o + n * n);
      (o = t.groundPoint2.x - t.anchorPoint2.x),
        (n = t.groundPoint2.y - t.anchorPoint2.y);
      var s = Math.sqrt(o * o + n * n),
        a = b2Math.b2Max(0.5 * b2PulleyJoint.b2_minPulleyLength, e),
        l = b2Math.b2Max(0.5 * b2PulleyJoint.b2_minPulleyLength, s);
      (this.m_constant = a + this.m_ratio * l),
        (this.m_maxLength1 = b2Math.b2Clamp(
          t.maxLength1,
          a,
          this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength
        )),
        (this.m_maxLength2 = b2Math.b2Clamp(
          t.maxLength2,
          l,
          (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio
        )),
        (this.m_pulleyImpulse = 0),
        (this.m_limitImpulse1 = 0),
        (this.m_limitImpulse2 = 0);
    },
    PrepareVelocitySolver: function () {
      var t,
        i = this.m_body1,
        o = this.m_body2;
      t = i.m_R;
      var n =
          t.col1.x * this.m_localAnchor1.x + t.col2.x * this.m_localAnchor1.y,
        e = t.col1.y * this.m_localAnchor1.x + t.col2.y * this.m_localAnchor1.y;
      t = o.m_R;
      var s =
          t.col1.x * this.m_localAnchor2.x + t.col2.x * this.m_localAnchor2.y,
        a = t.col1.y * this.m_localAnchor2.x + t.col2.y * this.m_localAnchor2.y,
        l = i.m_position.x + n,
        r = i.m_position.y + e,
        m = o.m_position.x + s,
        _ = o.m_position.y + a,
        h = this.m_ground.m_position.x + this.m_groundAnchor1.x,
        c = this.m_ground.m_position.y + this.m_groundAnchor1.y,
        u = this.m_ground.m_position.x + this.m_groundAnchor2.x,
        y = this.m_ground.m_position.y + this.m_groundAnchor2.y;
      this.m_u1.Set(l - h, r - c), this.m_u2.Set(m - u, _ - y);
      var b = this.m_u1.Length(),
        p = this.m_u2.Length();
      b > b2Settings.b2_linearSlop
        ? this.m_u1.Multiply(1 / b)
        : this.m_u1.SetZero(),
        p > b2Settings.b2_linearSlop
          ? this.m_u2.Multiply(1 / p)
          : this.m_u2.SetZero(),
        b < this.m_maxLength1
          ? ((this.m_limitState1 = b2Joint.e_inactiveLimit),
            (this.m_limitImpulse1 = 0))
          : ((this.m_limitState1 = b2Joint.e_atUpperLimit),
            (this.m_limitPositionImpulse1 = 0)),
        p < this.m_maxLength2
          ? ((this.m_limitState2 = b2Joint.e_inactiveLimit),
            (this.m_limitImpulse2 = 0))
          : ((this.m_limitState2 = b2Joint.e_atUpperLimit),
            (this.m_limitPositionImpulse2 = 0));
      var x = n * this.m_u1.y - e * this.m_u1.x,
        d = s * this.m_u2.y - a * this.m_u2.x;
      (this.m_limitMass1 = i.m_invMass + i.m_invI * x * x),
        (this.m_limitMass2 = o.m_invMass + o.m_invI * d * d),
        (this.m_pulleyMass =
          this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2),
        (this.m_limitMass1 = 1 / this.m_limitMass1),
        (this.m_limitMass2 = 1 / this.m_limitMass2),
        (this.m_pulleyMass = 1 / this.m_pulleyMass);
      var v = (-this.m_pulleyImpulse - this.m_limitImpulse1) * this.m_u1.x,
        f = (-this.m_pulleyImpulse - this.m_limitImpulse1) * this.m_u1.y,
        g =
          (-this.m_ratio * this.m_pulleyImpulse - this.m_limitImpulse2) *
          this.m_u2.x,
        M =
          (-this.m_ratio * this.m_pulleyImpulse - this.m_limitImpulse2) *
          this.m_u2.y;
      (i.m_linearVelocity.x += i.m_invMass * v),
        (i.m_linearVelocity.y += i.m_invMass * f),
        (i.m_angularVelocity += i.m_invI * (n * f - e * v)),
        (o.m_linearVelocity.x += o.m_invMass * g),
        (o.m_linearVelocity.y += o.m_invMass * M),
        (o.m_angularVelocity += o.m_invI * (s * M - a * g));
    },
    SolveVelocityConstraints: function (t) {
      var i,
        o = this.m_body1,
        n = this.m_body2;
      i = o.m_R;
      var e =
          i.col1.x * this.m_localAnchor1.x + i.col2.x * this.m_localAnchor1.y,
        s = i.col1.y * this.m_localAnchor1.x + i.col2.y * this.m_localAnchor1.y;
      i = n.m_R;
      var a,
        l,
        r,
        m,
        _,
        h,
        c,
        u,
        y,
        b,
        p,
        x = i.col1.x * this.m_localAnchor2.x + i.col2.x * this.m_localAnchor2.y,
        d = i.col1.y * this.m_localAnchor2.x + i.col2.y * this.m_localAnchor2.y;
      (a = o.m_linearVelocity.x + -o.m_angularVelocity * s),
        (l = o.m_linearVelocity.y + o.m_angularVelocity * e),
        (r = n.m_linearVelocity.x + -n.m_angularVelocity * d),
        (m = n.m_linearVelocity.y + n.m_angularVelocity * x),
        (y =
          -(this.m_u1.x * a + this.m_u1.y * l) -
          this.m_ratio * (this.m_u2.x * r + this.m_u2.y * m)),
        (b = -this.m_pulleyMass * y),
        (this.m_pulleyImpulse += b),
        (_ = -b * this.m_u1.x),
        (h = -b * this.m_u1.y),
        (c = -this.m_ratio * b * this.m_u2.x),
        (u = -this.m_ratio * b * this.m_u2.y),
        (o.m_linearVelocity.x += o.m_invMass * _),
        (o.m_linearVelocity.y += o.m_invMass * h),
        (o.m_angularVelocity += o.m_invI * (e * h - s * _)),
        (n.m_linearVelocity.x += n.m_invMass * c),
        (n.m_linearVelocity.y += n.m_invMass * u),
        (n.m_angularVelocity += n.m_invI * (x * u - d * c)),
        this.m_limitState1 == b2Joint.e_atUpperLimit &&
          ((a = o.m_linearVelocity.x + -o.m_angularVelocity * s),
          (l = o.m_linearVelocity.y + o.m_angularVelocity * e),
          (y = -(this.m_u1.x * a + this.m_u1.y * l)),
          (b = -this.m_limitMass1 * y),
          (p = this.m_limitImpulse1),
          (this.m_limitImpulse1 = b2Math.b2Max(0, this.m_limitImpulse1 + b)),
          (b = this.m_limitImpulse1 - p),
          (_ = -b * this.m_u1.x),
          (h = -b * this.m_u1.y),
          (o.m_linearVelocity.x += o.m_invMass * _),
          (o.m_linearVelocity.y += o.m_invMass * h),
          (o.m_angularVelocity += o.m_invI * (e * h - s * _))),
        this.m_limitState2 == b2Joint.e_atUpperLimit &&
          ((r = n.m_linearVelocity.x + -n.m_angularVelocity * d),
          (m = n.m_linearVelocity.y + n.m_angularVelocity * x),
          (y = -(this.m_u2.x * r + this.m_u2.y * m)),
          (b = -this.m_limitMass2 * y),
          (p = this.m_limitImpulse2),
          (this.m_limitImpulse2 = b2Math.b2Max(0, this.m_limitImpulse2 + b)),
          (b = this.m_limitImpulse2 - p),
          (c = -b * this.m_u2.x),
          (u = -b * this.m_u2.y),
          (n.m_linearVelocity.x += n.m_invMass * c),
          (n.m_linearVelocity.y += n.m_invMass * u),
          (n.m_angularVelocity += n.m_invI * (x * u - d * c)));
    },
    SolvePositionConstraints: function () {
      var t,
        i,
        o,
        n,
        e,
        s,
        a,
        l,
        r,
        m,
        _,
        h,
        c,
        u,
        y = this.m_body1,
        b = this.m_body2,
        p = this.m_ground.m_position.x + this.m_groundAnchor1.x,
        x = this.m_ground.m_position.y + this.m_groundAnchor1.y,
        d = this.m_ground.m_position.x + this.m_groundAnchor2.x,
        v = this.m_ground.m_position.y + this.m_groundAnchor2.y,
        f = 0;
      return (
        (t = y.m_R),
        (i =
          t.col1.x * this.m_localAnchor1.x + t.col2.x * this.m_localAnchor1.y),
        (o =
          t.col1.y * this.m_localAnchor1.x + t.col2.y * this.m_localAnchor1.y),
        (t = b.m_R),
        (n =
          t.col1.x * this.m_localAnchor2.x + t.col2.x * this.m_localAnchor2.y),
        (e =
          t.col1.y * this.m_localAnchor2.x + t.col2.y * this.m_localAnchor2.y),
        (s = y.m_position.x + i),
        (a = y.m_position.y + o),
        (l = b.m_position.x + n),
        (r = b.m_position.y + e),
        this.m_u1.Set(s - p, a - x),
        this.m_u2.Set(l - d, r - v),
        (m = this.m_u1.Length()),
        (_ = this.m_u2.Length()),
        m > b2Settings.b2_linearSlop
          ? this.m_u1.Multiply(1 / m)
          : this.m_u1.SetZero(),
        _ > b2Settings.b2_linearSlop
          ? this.m_u2.Multiply(1 / _)
          : this.m_u2.SetZero(),
        (h = this.m_constant - m - this.m_ratio * _),
        (f = b2Math.b2Max(f, Math.abs(h))),
        (h = b2Math.b2Clamp(
          h,
          -b2Settings.b2_maxLinearCorrection,
          b2Settings.b2_maxLinearCorrection
        )),
        (c = -this.m_pulleyMass * h),
        (s = -c * this.m_u1.x),
        (a = -c * this.m_u1.y),
        (l = -this.m_ratio * c * this.m_u2.x),
        (r = -this.m_ratio * c * this.m_u2.y),
        (y.m_position.x += y.m_invMass * s),
        (y.m_position.y += y.m_invMass * a),
        (y.m_rotation += y.m_invI * (i * a - o * s)),
        (b.m_position.x += b.m_invMass * l),
        (b.m_position.y += b.m_invMass * r),
        (b.m_rotation += b.m_invI * (n * r - e * l)),
        y.m_R.Set(y.m_rotation),
        b.m_R.Set(b.m_rotation),
        this.m_limitState1 == b2Joint.e_atUpperLimit &&
          ((t = y.m_R),
          (i =
            t.col1.x * this.m_localAnchor1.x +
            t.col2.x * this.m_localAnchor1.y),
          (o =
            t.col1.y * this.m_localAnchor1.x +
            t.col2.y * this.m_localAnchor1.y),
          (s = y.m_position.x + i),
          (a = y.m_position.y + o),
          this.m_u1.Set(s - p, a - x),
          (m = this.m_u1.Length()),
          m > b2Settings.b2_linearSlop
            ? ((this.m_u1.x *= 1 / m), (this.m_u1.y *= 1 / m))
            : this.m_u1.SetZero(),
          (h = this.m_maxLength1 - m),
          (f = b2Math.b2Max(f, -h)),
          (h = b2Math.b2Clamp(
            h + b2Settings.b2_linearSlop,
            -b2Settings.b2_maxLinearCorrection,
            0
          )),
          (c = -this.m_limitMass1 * h),
          (u = this.m_limitPositionImpulse1),
          (this.m_limitPositionImpulse1 = b2Math.b2Max(
            0,
            this.m_limitPositionImpulse1 + c
          )),
          (c = this.m_limitPositionImpulse1 - u),
          (s = -c * this.m_u1.x),
          (a = -c * this.m_u1.y),
          (y.m_position.x += y.m_invMass * s),
          (y.m_position.y += y.m_invMass * a),
          (y.m_rotation += y.m_invI * (i * a - o * s)),
          y.m_R.Set(y.m_rotation)),
        this.m_limitState2 == b2Joint.e_atUpperLimit &&
          ((t = b.m_R),
          (n =
            t.col1.x * this.m_localAnchor2.x +
            t.col2.x * this.m_localAnchor2.y),
          (e =
            t.col1.y * this.m_localAnchor2.x +
            t.col2.y * this.m_localAnchor2.y),
          (l = b.m_position.x + n),
          (r = b.m_position.y + e),
          this.m_u2.Set(l - d, r - v),
          (_ = this.m_u2.Length()),
          _ > b2Settings.b2_linearSlop
            ? ((this.m_u2.x *= 1 / _), (this.m_u2.y *= 1 / _))
            : this.m_u2.SetZero(),
          (h = this.m_maxLength2 - _),
          (f = b2Math.b2Max(f, -h)),
          (h = b2Math.b2Clamp(
            h + b2Settings.b2_linearSlop,
            -b2Settings.b2_maxLinearCorrection,
            0
          )),
          (c = -this.m_limitMass2 * h),
          (u = this.m_limitPositionImpulse2),
          (this.m_limitPositionImpulse2 = b2Math.b2Max(
            0,
            this.m_limitPositionImpulse2 + c
          )),
          (c = this.m_limitPositionImpulse2 - u),
          (l = -c * this.m_u2.x),
          (r = -c * this.m_u2.y),
          (b.m_position.x += b.m_invMass * l),
          (b.m_position.y += b.m_invMass * r),
          (b.m_rotation += b.m_invI * (n * r - e * l)),
          b.m_R.Set(b.m_rotation)),
        f < b2Settings.b2_linearSlop
      );
    },
    m_ground: null,
    m_groundAnchor1: new b2Vec2(),
    m_groundAnchor2: new b2Vec2(),
    m_localAnchor1: new b2Vec2(),
    m_localAnchor2: new b2Vec2(),
    m_u1: new b2Vec2(),
    m_u2: new b2Vec2(),
    m_constant: null,
    m_ratio: null,
    m_maxLength1: null,
    m_maxLength2: null,
    m_pulleyMass: null,
    m_limitMass1: null,
    m_limitMass2: null,
    m_pulleyImpulse: null,
    m_limitImpulse1: null,
    m_limitImpulse2: null,
    m_limitPositionImpulse1: null,
    m_limitPositionImpulse2: null,
    m_limitState1: 0,
    m_limitState2: 0,
  }),
  (b2PulleyJoint.b2_minPulleyLength = b2Settings.b2_lengthUnitsPerMeter);
var b2PulleyJointDef = new b2Root();
jQuery.extend(b2PulleyJointDef.prototype, b2JointDef.prototype),
  jQuery.extend(b2PulleyJointDef.prototype, {
    initialize: function () {
      (this.type = b2Joint.e_unknownJoint),
        (this.userData = null),
        (this.body1 = null),
        (this.body2 = null),
        (this.collideConnected = !1),
        (this.groundPoint1 = new b2Vec2()),
        (this.groundPoint2 = new b2Vec2()),
        (this.anchorPoint1 = new b2Vec2()),
        (this.anchorPoint2 = new b2Vec2()),
        (this.type = b2Joint.e_pulleyJoint),
        this.groundPoint1.Set(-1, 1),
        this.groundPoint2.Set(1, 1),
        this.anchorPoint1.Set(-1, 0),
        this.anchorPoint2.Set(1, 0),
        (this.maxLength1 = 0.5 * b2PulleyJoint.b2_minPulleyLength),
        (this.maxLength2 = 0.5 * b2PulleyJoint.b2_minPulleyLength),
        (this.ratio = 1),
        (this.collideConnected = !0);
    },
    groundPoint1: new b2Vec2(),
    groundPoint2: new b2Vec2(),
    anchorPoint1: new b2Vec2(),
    anchorPoint2: new b2Vec2(),
    maxLength1: null,
    maxLength2: null,
    ratio: null,
  });
var b2RevoluteJoint = new b2Root();
jQuery.extend(b2RevoluteJoint.prototype, b2Joint.prototype),
  jQuery.extend(b2RevoluteJoint.prototype, {
    GetAnchor1: function () {
      var t = this.m_body1.m_R;
      return new b2Vec2(
        this.m_body1.m_position.x +
          (t.col1.x * this.m_localAnchor1.x + t.col2.x * this.m_localAnchor1.y),
        this.m_body1.m_position.y +
          (t.col1.y * this.m_localAnchor1.x + t.col2.y * this.m_localAnchor1.y)
      );
    },
    GetAnchor2: function () {
      var t = this.m_body2.m_R;
      return new b2Vec2(
        this.m_body2.m_position.x +
          (t.col1.x * this.m_localAnchor2.x + t.col2.x * this.m_localAnchor2.y),
        this.m_body2.m_position.y +
          (t.col1.y * this.m_localAnchor2.x + t.col2.y * this.m_localAnchor2.y)
      );
    },
    GetJointAngle: function () {
      return this.m_body2.m_rotation - this.m_body1.m_rotation;
    },
    GetJointSpeed: function () {
      return this.m_body2.m_angularVelocity - this.m_body1.m_angularVelocity;
    },
    GetMotorTorque: function (t) {
      return t * this.m_motorImpulse;
    },
    SetMotorSpeed: function (t) {
      this.m_motorSpeed = t;
    },
    SetMotorTorque: function (t) {
      this.m_maxMotorTorque = t;
    },
    GetReactionForce: function (t) {
      var i = this.m_ptpImpulse.Copy();
      return i.Multiply(t), i;
    },
    GetReactionTorque: function (t) {
      return t * this.m_limitImpulse;
    },
    initialize: function (t) {
      (this.m_node1 = new b2JointNode()),
        (this.m_node2 = new b2JointNode()),
        (this.m_type = t.type),
        (this.m_prev = null),
        (this.m_next = null),
        (this.m_body1 = t.body1),
        (this.m_body2 = t.body2),
        (this.m_collideConnected = t.collideConnected),
        (this.m_islandFlag = !1),
        (this.m_userData = t.userData),
        (this.K = new b2Mat22()),
        (this.K1 = new b2Mat22()),
        (this.K2 = new b2Mat22()),
        (this.K3 = new b2Mat22()),
        (this.m_localAnchor1 = new b2Vec2()),
        (this.m_localAnchor2 = new b2Vec2()),
        (this.m_ptpImpulse = new b2Vec2()),
        (this.m_ptpMass = new b2Mat22());
      var i, o, n;
      (i = this.m_body1.m_R),
        (o = t.anchorPoint.x - this.m_body1.m_position.x),
        (n = t.anchorPoint.y - this.m_body1.m_position.y),
        (this.m_localAnchor1.x = o * i.col1.x + n * i.col1.y),
        (this.m_localAnchor1.y = o * i.col2.x + n * i.col2.y),
        (i = this.m_body2.m_R),
        (o = t.anchorPoint.x - this.m_body2.m_position.x),
        (n = t.anchorPoint.y - this.m_body2.m_position.y),
        (this.m_localAnchor2.x = o * i.col1.x + n * i.col1.y),
        (this.m_localAnchor2.y = o * i.col2.x + n * i.col2.y),
        (this.m_intialAngle =
          this.m_body2.m_rotation - this.m_body1.m_rotation),
        this.m_ptpImpulse.Set(0, 0),
        (this.m_motorImpulse = 0),
        (this.m_limitImpulse = 0),
        (this.m_limitPositionImpulse = 0),
        (this.m_lowerAngle = t.lowerAngle),
        (this.m_upperAngle = t.upperAngle),
        (this.m_maxMotorTorque = t.motorTorque),
        (this.m_motorSpeed = t.motorSpeed),
        (this.m_enableLimit = t.enableLimit),
        (this.m_enableMotor = t.enableMotor);
    },
    K: new b2Mat22(),
    K1: new b2Mat22(),
    K2: new b2Mat22(),
    K3: new b2Mat22(),
    PrepareVelocitySolver: function () {
      var t,
        i = this.m_body1,
        o = this.m_body2;
      t = i.m_R;
      var n =
          t.col1.x * this.m_localAnchor1.x + t.col2.x * this.m_localAnchor1.y,
        e = t.col1.y * this.m_localAnchor1.x + t.col2.y * this.m_localAnchor1.y;
      t = o.m_R;
      var s =
          t.col1.x * this.m_localAnchor2.x + t.col2.x * this.m_localAnchor2.y,
        a = t.col1.y * this.m_localAnchor2.x + t.col2.y * this.m_localAnchor2.y,
        l = i.m_invMass,
        r = o.m_invMass,
        m = i.m_invI,
        _ = o.m_invI;
      if (
        ((this.K1.col1.x = l + r),
        (this.K1.col2.x = 0),
        (this.K1.col1.y = 0),
        (this.K1.col2.y = l + r),
        (this.K2.col1.x = m * e * e),
        (this.K2.col2.x = -m * n * e),
        (this.K2.col1.y = -m * n * e),
        (this.K2.col2.y = m * n * n),
        (this.K3.col1.x = _ * a * a),
        (this.K3.col2.x = -_ * s * a),
        (this.K3.col1.y = -_ * s * a),
        (this.K3.col2.y = _ * s * s),
        this.K.SetM(this.K1),
        this.K.AddM(this.K2),
        this.K.AddM(this.K3),
        this.K.Invert(this.m_ptpMass),
        (this.m_motorMass = 1 / (m + _)),
        0 == this.m_enableMotor && (this.m_motorImpulse = 0),
        this.m_enableLimit)
      ) {
        var h = o.m_rotation - i.m_rotation - this.m_intialAngle;
        b2Math.b2Abs(this.m_upperAngle - this.m_lowerAngle) <
        2 * b2Settings.b2_angularSlop
          ? (this.m_limitState = b2Joint.e_equalLimits)
          : h <= this.m_lowerAngle
          ? (this.m_limitState != b2Joint.e_atLowerLimit &&
              (this.m_limitImpulse = 0),
            (this.m_limitState = b2Joint.e_atLowerLimit))
          : h >= this.m_upperAngle
          ? (this.m_limitState != b2Joint.e_atUpperLimit &&
              (this.m_limitImpulse = 0),
            (this.m_limitState = b2Joint.e_atUpperLimit))
          : ((this.m_limitState = b2Joint.e_inactiveLimit),
            (this.m_limitImpulse = 0));
      } else this.m_limitImpulse = 0;
      b2World.s_enableWarmStarting
        ? ((i.m_linearVelocity.x -= l * this.m_ptpImpulse.x),
          (i.m_linearVelocity.y -= l * this.m_ptpImpulse.y),
          (i.m_angularVelocity -=
            m *
            (n * this.m_ptpImpulse.y -
              e * this.m_ptpImpulse.x +
              this.m_motorImpulse +
              this.m_limitImpulse)),
          (o.m_linearVelocity.x += r * this.m_ptpImpulse.x),
          (o.m_linearVelocity.y += r * this.m_ptpImpulse.y),
          (o.m_angularVelocity +=
            _ *
            (s * this.m_ptpImpulse.y -
              a * this.m_ptpImpulse.x +
              this.m_motorImpulse +
              this.m_limitImpulse)))
        : (this.m_ptpImpulse.SetZero(),
          (this.m_motorImpulse = 0),
          (this.m_limitImpulse = 0)),
        (this.m_limitPositionImpulse = 0);
    },
    SolveVelocityConstraints: function (t) {
      var i,
        o = this.m_body1,
        n = this.m_body2;
      i = o.m_R;
      var e =
          i.col1.x * this.m_localAnchor1.x + i.col2.x * this.m_localAnchor1.y,
        s = i.col1.y * this.m_localAnchor1.x + i.col2.y * this.m_localAnchor1.y;
      i = n.m_R;
      var a,
        l = i.col1.x * this.m_localAnchor2.x + i.col2.x * this.m_localAnchor2.y,
        r = i.col1.y * this.m_localAnchor2.x + i.col2.y * this.m_localAnchor2.y,
        m =
          n.m_linearVelocity.x +
          -n.m_angularVelocity * r -
          o.m_linearVelocity.x -
          -o.m_angularVelocity * s,
        _ =
          n.m_linearVelocity.y +
          n.m_angularVelocity * l -
          o.m_linearVelocity.y -
          o.m_angularVelocity * e,
        h = -(this.m_ptpMass.col1.x * m + this.m_ptpMass.col2.x * _),
        c = -(this.m_ptpMass.col1.y * m + this.m_ptpMass.col2.y * _);
      if (
        ((this.m_ptpImpulse.x += h),
        (this.m_ptpImpulse.y += c),
        (o.m_linearVelocity.x -= o.m_invMass * h),
        (o.m_linearVelocity.y -= o.m_invMass * c),
        (o.m_angularVelocity -= o.m_invI * (e * c - s * h)),
        (n.m_linearVelocity.x += n.m_invMass * h),
        (n.m_linearVelocity.y += n.m_invMass * c),
        (n.m_angularVelocity += n.m_invI * (l * c - r * h)),
        this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits)
      ) {
        var u = n.m_angularVelocity - o.m_angularVelocity - this.m_motorSpeed,
          y = -this.m_motorMass * u,
          b = this.m_motorImpulse;
        (this.m_motorImpulse = b2Math.b2Clamp(
          this.m_motorImpulse + y,
          -t.dt * this.m_maxMotorTorque,
          t.dt * this.m_maxMotorTorque
        )),
          (y = this.m_motorImpulse - b),
          (o.m_angularVelocity -= o.m_invI * y),
          (n.m_angularVelocity += n.m_invI * y);
      }
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
        var p = n.m_angularVelocity - o.m_angularVelocity,
          x = -this.m_motorMass * p;
        this.m_limitState == b2Joint.e_equalLimits
          ? (this.m_limitImpulse += x)
          : this.m_limitState == b2Joint.e_atLowerLimit
          ? ((a = this.m_limitImpulse),
            (this.m_limitImpulse = b2Math.b2Max(this.m_limitImpulse + x, 0)),
            (x = this.m_limitImpulse - a))
          : this.m_limitState == b2Joint.e_atUpperLimit &&
            ((a = this.m_limitImpulse),
            (this.m_limitImpulse = b2Math.b2Min(this.m_limitImpulse + x, 0)),
            (x = this.m_limitImpulse - a)),
          (o.m_angularVelocity -= o.m_invI * x),
          (n.m_angularVelocity += n.m_invI * x);
      }
    },
    SolvePositionConstraints: function () {
      var t,
        i,
        o,
        n = this.m_body1,
        e = this.m_body2,
        s = 0;
      o = n.m_R;
      var a =
          o.col1.x * this.m_localAnchor1.x + o.col2.x * this.m_localAnchor1.y,
        l = o.col1.y * this.m_localAnchor1.x + o.col2.y * this.m_localAnchor1.y;
      o = e.m_R;
      var r =
          o.col1.x * this.m_localAnchor2.x + o.col2.x * this.m_localAnchor2.y,
        m = o.col1.y * this.m_localAnchor2.x + o.col2.y * this.m_localAnchor2.y,
        _ = n.m_position.x + a,
        h = n.m_position.y + l,
        c = e.m_position.x + r,
        u = e.m_position.y + m,
        y = c - _,
        b = u - h;
      s = Math.sqrt(y * y + b * b);
      var p = n.m_invMass,
        x = e.m_invMass,
        d = n.m_invI,
        v = e.m_invI;
      (this.K1.col1.x = p + x),
        (this.K1.col2.x = 0),
        (this.K1.col1.y = 0),
        (this.K1.col2.y = p + x),
        (this.K2.col1.x = d * l * l),
        (this.K2.col2.x = -d * a * l),
        (this.K2.col1.y = -d * a * l),
        (this.K2.col2.y = d * a * a),
        (this.K3.col1.x = v * m * m),
        (this.K3.col2.x = -v * r * m),
        (this.K3.col1.y = -v * r * m),
        (this.K3.col2.y = v * r * r),
        this.K.SetM(this.K1),
        this.K.AddM(this.K2),
        this.K.AddM(this.K3),
        this.K.Solve(b2RevoluteJoint.tImpulse, -y, -b);
      var f = b2RevoluteJoint.tImpulse.x,
        g = b2RevoluteJoint.tImpulse.y;
      (n.m_position.x -= n.m_invMass * f),
        (n.m_position.y -= n.m_invMass * g),
        (n.m_rotation -= n.m_invI * (a * g - l * f)),
        n.m_R.Set(n.m_rotation),
        (e.m_position.x += e.m_invMass * f),
        (e.m_position.y += e.m_invMass * g),
        (e.m_rotation += e.m_invI * (r * g - m * f)),
        e.m_R.Set(e.m_rotation);
      var M = 0;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
        var V = e.m_rotation - n.m_rotation - this.m_intialAngle,
          S = 0;
        this.m_limitState == b2Joint.e_equalLimits
          ? ((i = b2Math.b2Clamp(
              V,
              -b2Settings.b2_maxAngularCorrection,
              b2Settings.b2_maxAngularCorrection
            )),
            (S = -this.m_motorMass * i),
            (M = b2Math.b2Abs(i)))
          : this.m_limitState == b2Joint.e_atLowerLimit
          ? ((i = V - this.m_lowerAngle),
            (M = b2Math.b2Max(0, -i)),
            (i = b2Math.b2Clamp(
              i + b2Settings.b2_angularSlop,
              -b2Settings.b2_maxAngularCorrection,
              0
            )),
            (S = -this.m_motorMass * i),
            (t = this.m_limitPositionImpulse),
            (this.m_limitPositionImpulse = b2Math.b2Max(
              this.m_limitPositionImpulse + S,
              0
            )),
            (S = this.m_limitPositionImpulse - t))
          : this.m_limitState == b2Joint.e_atUpperLimit &&
            ((i = V - this.m_upperAngle),
            (M = b2Math.b2Max(0, i)),
            (i = b2Math.b2Clamp(
              i - b2Settings.b2_angularSlop,
              0,
              b2Settings.b2_maxAngularCorrection
            )),
            (S = -this.m_motorMass * i),
            (t = this.m_limitPositionImpulse),
            (this.m_limitPositionImpulse = b2Math.b2Min(
              this.m_limitPositionImpulse + S,
              0
            )),
            (S = this.m_limitPositionImpulse - t)),
          (n.m_rotation -= n.m_invI * S),
          n.m_R.Set(n.m_rotation),
          (e.m_rotation += e.m_invI * S),
          e.m_R.Set(e.m_rotation);
      }
      return s <= b2Settings.b2_linearSlop && M <= b2Settings.b2_angularSlop;
    },
    m_localAnchor1: new b2Vec2(),
    m_localAnchor2: new b2Vec2(),
    m_ptpImpulse: new b2Vec2(),
    m_motorImpulse: null,
    m_limitImpulse: null,
    m_limitPositionImpulse: null,
    m_ptpMass: new b2Mat22(),
    m_motorMass: null,
    m_intialAngle: null,
    m_lowerAngle: null,
    m_upperAngle: null,
    m_maxMotorTorque: null,
    m_motorSpeed: null,
    m_enableLimit: null,
    m_enableMotor: null,
    m_limitState: 0,
  }),
  (b2RevoluteJoint.tImpulse = new b2Vec2());
var b2RevoluteJointDef = new b2Root();
jQuery.extend(b2RevoluteJointDef.prototype, b2JointDef.prototype),
  jQuery.extend(b2RevoluteJointDef.prototype, {
    initialize: function () {
      (this.type = b2Joint.e_unknownJoint),
        (this.userData = null),
        (this.body1 = null),
        (this.body2 = null),
        (this.collideConnected = !1),
        (this.type = b2Joint.e_revoluteJoint),
        (this.anchorPoint = new b2Vec2(0, 0)),
        (this.lowerAngle = 0),
        (this.upperAngle = 0),
        (this.motorTorque = 0),
        (this.motorSpeed = 0),
        (this.enableLimit = !1),
        (this.enableMotor = !1);
    },
    anchorPoint: null,
    lowerAngle: null,
    upperAngle: null,
    motorTorque: null,
    motorSpeed: null,
    enableLimit: null,
    enableMotor: null,
  });
var b2NullContact = new b2Root();
jQuery.extend(b2NullContact.prototype, b2Contact.prototype),
  jQuery.extend(b2NullContact.prototype, {
    initialize: function (t, i) {
      return (
        (this.m_node1 = new b2ContactNode()),
        (this.m_node2 = new b2ContactNode()),
        (this.m_flags = 0),
        t && i
          ? ((this.m_shape1 = t),
            (this.m_shape2 = i),
            (this.m_manifoldCount = 0),
            (this.m_friction = Math.sqrt(
              this.m_shape1.m_friction * this.m_shape2.m_friction
            )),
            (this.m_restitution = b2Math.b2Max(
              this.m_shape1.m_restitution,
              this.m_shape2.m_restitution
            )),
            (this.m_prev = null),
            (this.m_next = null),
            (this.m_node1.contact = null),
            (this.m_node1.prev = null),
            (this.m_node1.next = null),
            (this.m_node1.other = null),
            (this.m_node2.contact = null),
            (this.m_node2.prev = null),
            (this.m_node2.next = null),
            void (this.m_node2.other = null))
          : ((this.m_shape1 = null), void (this.m_shape2 = null))
      );
    },
    Evaluate: function () {},
    GetManifolds: function () {
      return null;
    },
  });
var b2ContactManager = new b2Root();
jQuery.extend(b2ContactManager.prototype, b2PairCallback.prototype),
  jQuery.extend(b2ContactManager.prototype, {
    initialize: function () {
      (this.m_nullContact = new b2NullContact()),
        (this.m_world = null),
        (this.m_destroyImmediate = !1);
    },
    PairAdded: function (t, i) {
      var o = t,
        n = i,
        e = o.m_body,
        s = n.m_body;
      if (e.IsStatic() && s.IsStatic()) return this.m_nullContact;
      if (o.m_body == n.m_body) return this.m_nullContact;
      if (s.IsConnected(e)) return this.m_nullContact;
      if (
        null != this.m_world.m_filter &&
        0 == this.m_world.m_filter.ShouldCollide(o, n)
      )
        return this.m_nullContact;
      if (0 == s.m_invMass) {
        var a = o;
        (o = n), (n = a);
        var l = e;
        (e = s), (s = l);
      }
      var r = b2Contact.Create(o, n, this.m_world.m_blockAllocator);
      return null == r
        ? this.m_nullContact
        : ((r.m_prev = null),
          (r.m_next = this.m_world.m_contactList),
          null != this.m_world.m_contactList &&
            (this.m_world.m_contactList.m_prev = r),
          (this.m_world.m_contactList = r),
          this.m_world.m_contactCount++,
          r);
    },
    PairRemoved: function (t, i, o) {
      if (null != o) {
        var n = o;
        n != this.m_nullContact &&
          (1 == this.m_destroyImmediate
            ? (this.DestroyContact(n), (n = null))
            : (n.m_flags |= b2Contact.e_destroyFlag));
      }
    },
    DestroyContact: function (t) {
      if (
        (t.m_prev && (t.m_prev.m_next = t.m_next),
        t.m_next && (t.m_next.m_prev = t.m_prev),
        t == this.m_world.m_contactList &&
          (this.m_world.m_contactList = t.m_next),
        t.GetManifoldCount() > 0)
      ) {
        var i = t.m_shape1.m_body,
          o = t.m_shape2.m_body,
          n = t.m_node1,
          e = t.m_node2;
        i.WakeUp(),
          o.WakeUp(),
          n.prev && (n.prev.next = n.next),
          n.next && (n.next.prev = n.prev),
          n == i.m_contactList && (i.m_contactList = n.next),
          (n.prev = null),
          (n.next = null),
          e.prev && (e.prev.next = e.next),
          e.next && (e.next.prev = e.prev),
          e == o.m_contactList && (o.m_contactList = e.next),
          (e.prev = null),
          (e.next = null);
      }
      b2Contact.Destroy(t, this.m_world.m_blockAllocator),
        --this.m_world.m_contactCount;
    },
    CleanContactList: function () {
      for (var t = this.m_world.m_contactList; null != t; ) {
        var i = t;
        (t = t.m_next),
          i.m_flags & b2Contact.e_destroyFlag &&
            (this.DestroyContact(i), (i = null));
      }
    },
    Collide: function () {
      for (
        var t, i, o, n, e = this.m_world.m_contactList;
        null != e;
        e = e.m_next
      )
        if (
          !e.m_shape1.m_body.IsSleeping() ||
          !e.m_shape2.m_body.IsSleeping()
        ) {
          var s = e.GetManifoldCount();
          e.Evaluate();
          var a = e.GetManifoldCount();
          0 == s && a > 0
            ? ((t = e.m_shape1.m_body),
              (i = e.m_shape2.m_body),
              (o = e.m_node1),
              (n = e.m_node2),
              (o.contact = e),
              (o.other = i),
              (o.prev = null),
              (o.next = t.m_contactList),
              null != o.next && (o.next.prev = e.m_node1),
              (t.m_contactList = e.m_node1),
              (n.contact = e),
              (n.other = t),
              (n.prev = null),
              (n.next = i.m_contactList),
              null != n.next && (n.next.prev = n),
              (i.m_contactList = n))
            : s > 0 &&
              0 == a &&
              ((t = e.m_shape1.m_body),
              (i = e.m_shape2.m_body),
              (o = e.m_node1),
              (n = e.m_node2),
              o.prev && (o.prev.next = o.next),
              o.next && (o.next.prev = o.prev),
              o == t.m_contactList && (t.m_contactList = o.next),
              (o.prev = null),
              (o.next = null),
              n.prev && (n.prev.next = n.next),
              n.next && (n.next.prev = n.prev),
              n == i.m_contactList && (i.m_contactList = n.next),
              (n.prev = null),
              (n.next = null));
        }
    },
    m_world: null,
    m_nullContact: new b2NullContact(),
    m_destroyImmediate: null,
  });
var b2Island = new b2Root();
jQuery.extend(b2Island.prototype, {
  initialize: function (t, i, o, n) {
    var e = 0;
    for (
      this.m_bodyCapacity = t,
        this.m_contactCapacity = i,
        this.m_jointCapacity = o,
        this.m_bodyCount = 0,
        this.m_contactCount = 0,
        this.m_jointCount = 0,
        this.m_bodies = new Array(t),
        e = 0;
      t > e;
      e++
    )
      this.m_bodies[e] = null;
    for (this.m_contacts = new Array(i), e = 0; i > e; e++)
      this.m_contacts[e] = null;
    for (this.m_joints = new Array(o), e = 0; o > e; e++)
      this.m_joints[e] = null;
    this.m_allocator = n;
  },
  Clear: function () {
    (this.m_bodyCount = 0), (this.m_contactCount = 0), (this.m_jointCount = 0);
  },
  Solve: function (t, i) {
    var o,
      n = 0;
    for (n = 0; n < this.m_bodyCount; ++n)
      (o = this.m_bodies[n]),
        0 != o.m_invMass &&
          (o.m_linearVelocity.Add(
            b2Math.MulFV(
              t.dt,
              b2Math.AddVV(i, b2Math.MulFV(o.m_invMass, o.m_force))
            )
          ),
          (o.m_angularVelocity += t.dt * o.m_invI * o.m_torque),
          o.m_linearVelocity.Multiply(o.m_linearDamping),
          (o.m_angularVelocity *= o.m_angularDamping),
          o.m_position0.SetV(o.m_position),
          (o.m_rotation0 = o.m_rotation));
    var e = new b2ContactSolver(
      this.m_contacts,
      this.m_contactCount,
      this.m_allocator
    );
    for (e.PreSolve(), n = 0; n < this.m_jointCount; ++n)
      this.m_joints[n].PrepareVelocitySolver();
    for (n = 0; n < t.iterations; ++n) {
      e.SolveVelocityConstraints();
      for (var s = 0; s < this.m_jointCount; ++s)
        this.m_joints[s].SolveVelocityConstraints(t);
    }
    for (n = 0; n < this.m_bodyCount; ++n)
      (o = this.m_bodies[n]),
        0 != o.m_invMass &&
          ((o.m_position.x += t.dt * o.m_linearVelocity.x),
          (o.m_position.y += t.dt * o.m_linearVelocity.y),
          (o.m_rotation += t.dt * o.m_angularVelocity),
          o.m_R.Set(o.m_rotation));
    for (n = 0; n < this.m_jointCount; ++n)
      this.m_joints[n].PreparePositionSolver();
    if (b2World.s_enablePositionCorrection)
      for (
        b2Island.m_positionIterationCount = 0;
        b2Island.m_positionIterationCount < t.iterations;
        ++b2Island.m_positionIterationCount
      ) {
        var a = e.SolvePositionConstraints(b2Settings.b2_contactBaumgarte),
          l = !0;
        for (n = 0; n < this.m_jointCount; ++n) {
          var r = this.m_joints[n].SolvePositionConstraints();
          l = l && r;
        }
        if (a && l) break;
      }
    for (e.PostSolve(), n = 0; n < this.m_bodyCount; ++n)
      (o = this.m_bodies[n]),
        0 != o.m_invMass &&
          (o.m_R.Set(o.m_rotation),
          o.SynchronizeShapes(),
          o.m_force.Set(0, 0),
          (o.m_torque = 0));
  },
  UpdateSleep: function (t) {
    var i,
      o = 0,
      n = Number.MAX_VALUE,
      e =
        b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance,
      s =
        b2Settings.b2_angularSleepTolerance *
        b2Settings.b2_angularSleepTolerance;
    for (o = 0; o < this.m_bodyCount; ++o)
      (i = this.m_bodies[o]),
        0 != i.m_invMass &&
          (0 == (i.m_flags & b2Body.e_allowSleepFlag) &&
            ((i.m_sleepTime = 0), (n = 0)),
          0 == (i.m_flags & b2Body.e_allowSleepFlag) ||
          i.m_angularVelocity * i.m_angularVelocity > s ||
          b2Math.b2Dot(i.m_linearVelocity, i.m_linearVelocity) > e
            ? ((i.m_sleepTime = 0), (n = 0))
            : ((i.m_sleepTime += t), (n = b2Math.b2Min(n, i.m_sleepTime))));
    if (n >= b2Settings.b2_timeToSleep)
      for (o = 0; o < this.m_bodyCount; ++o)
        (i = this.m_bodies[o]), (i.m_flags |= b2Body.e_sleepFlag);
  },
  AddBody: function (t) {
    this.m_bodies[this.m_bodyCount++] = t;
  },
  AddContact: function (t) {
    this.m_contacts[this.m_contactCount++] = t;
  },
  AddJoint: function (t) {
    this.m_joints[this.m_jointCount++] = t;
  },
  m_allocator: null,
  m_bodies: null,
  m_contacts: null,
  m_joints: null,
  m_bodyCount: 0,
  m_jointCount: 0,
  m_contactCount: 0,
  m_bodyCapacity: 0,
  m_contactCapacity: 0,
  m_jointCapacity: 0,
  m_positionError: null,
}),
  (b2Island.m_positionIterationCount = 0);
var b2TimeStep = new b2Root();
jQuery.extend(b2TimeStep.prototype, {
  dt: null,
  inv_dt: null,
  iterations: 0,
  initialize: function () {},
});
var b2World = new b2Root();
jQuery.extend(b2World.prototype, {
  initialize: function (t, i, o) {
    (this.step = new b2TimeStep()),
      (this.m_contactManager = new b2ContactManager()),
      (this.m_listener = null),
      (this.m_filter = b2CollisionFilter.b2_defaultFilter),
      (this.m_bodyList = null),
      (this.m_contactList = null),
      (this.m_jointList = null),
      (this.m_bodyCount = 0),
      (this.m_contactCount = 0),
      (this.m_jointCount = 0),
      (this.m_bodyDestroyList = null),
      (this.m_allowSleep = o),
      (this.m_gravity = i),
      (this.m_contactManager.m_world = this),
      (this.m_broadPhase = new b2BroadPhase(t, this.m_contactManager));
    var n = new b2BodyDef();
    this.m_groundBody = this.CreateBody(n);
  },
  SetListener: function (t) {
    this.m_listener = t;
  },
  SetFilter: function (t) {
    this.m_filter = t;
  },
  CreateBody: function (t) {
    var i = new b2Body(t, this);
    return (
      (i.m_prev = null),
      (i.m_next = this.m_bodyList),
      this.m_bodyList && (this.m_bodyList.m_prev = i),
      (this.m_bodyList = i),
      ++this.m_bodyCount,
      i
    );
  },
  DestroyBody: function (t) {
    t.m_flags & b2Body.e_destroyFlag ||
      (t.m_prev && (t.m_prev.m_next = t.m_next),
      t.m_next && (t.m_next.m_prev = t.m_prev),
      t == this.m_bodyList && (this.m_bodyList = t.m_next),
      (t.m_flags |= b2Body.e_destroyFlag),
      --this.m_bodyCount,
      (t.m_prev = null),
      (t.m_next = this.m_bodyDestroyList),
      (this.m_bodyDestroyList = t));
  },
  CleanBodyList: function () {
    this.m_contactManager.m_destroyImmediate = !0;
    for (var t = this.m_bodyDestroyList; t; ) {
      var i = t;
      t = t.m_next;
      for (var o = i.m_jointList; o; ) {
        var n = o;
        (o = o.next),
          this.m_listener && this.m_listener.NotifyJointDestroyed(n.joint),
          this.DestroyJoint(n.joint);
      }
      i.Destroy();
    }
    (this.m_bodyDestroyList = null),
      (this.m_contactManager.m_destroyImmediate = !1);
  },
  CreateJoint: function (t) {
    var i = b2Joint.Create(t, this.m_blockAllocator);
    if (
      ((i.m_prev = null),
      (i.m_next = this.m_jointList),
      this.m_jointList && (this.m_jointList.m_prev = i),
      (this.m_jointList = i),
      ++this.m_jointCount,
      (i.m_node1.joint = i),
      (i.m_node1.other = i.m_body2),
      (i.m_node1.prev = null),
      (i.m_node1.next = i.m_body1.m_jointList),
      i.m_body1.m_jointList && (i.m_body1.m_jointList.prev = i.m_node1),
      (i.m_body1.m_jointList = i.m_node1),
      (i.m_node2.joint = i),
      (i.m_node2.other = i.m_body1),
      (i.m_node2.prev = null),
      (i.m_node2.next = i.m_body2.m_jointList),
      i.m_body2.m_jointList && (i.m_body2.m_jointList.prev = i.m_node2),
      (i.m_body2.m_jointList = i.m_node2),
      0 == t.collideConnected)
    )
      for (
        var o = t.body1.m_shapeCount < t.body2.m_shapeCount ? t.body1 : t.body2,
          n = o.m_shapeList;
        n;
        n = n.m_next
      )
        n.ResetProxy(this.m_broadPhase);
    return i;
  },
  DestroyJoint: function (t) {
    var i = t.m_collideConnected;
    t.m_prev && (t.m_prev.m_next = t.m_next),
      t.m_next && (t.m_next.m_prev = t.m_prev),
      t == this.m_jointList && (this.m_jointList = t.m_next);
    var o = t.m_body1,
      n = t.m_body2;
    if (
      (o.WakeUp(),
      n.WakeUp(),
      t.m_node1.prev && (t.m_node1.prev.next = t.m_node1.next),
      t.m_node1.next && (t.m_node1.next.prev = t.m_node1.prev),
      t.m_node1 == o.m_jointList && (o.m_jointList = t.m_node1.next),
      (t.m_node1.prev = null),
      (t.m_node1.next = null),
      t.m_node2.prev && (t.m_node2.prev.next = t.m_node2.next),
      t.m_node2.next && (t.m_node2.next.prev = t.m_node2.prev),
      t.m_node2 == n.m_jointList && (n.m_jointList = t.m_node2.next),
      (t.m_node2.prev = null),
      (t.m_node2.next = null),
      b2Joint.Destroy(t, this.m_blockAllocator),
      --this.m_jointCount,
      0 == i)
    )
      for (
        var e = o.m_shapeCount < n.m_shapeCount ? o : n, s = e.m_shapeList;
        s;
        s = s.m_next
      )
        s.ResetProxy(this.m_broadPhase);
  },
  GetGroundBody: function () {
    return this.m_groundBody;
  },
  step: new b2TimeStep(),
  Step: function (t, i) {
    var o, n;
    (this.step.dt = t),
      (this.step.iterations = i),
      t > 0 ? (this.step.inv_dt = 1 / t) : (this.step.inv_dt = 0),
      (this.m_positionIterationCount = 0),
      this.m_contactManager.CleanContactList(),
      this.CleanBodyList(),
      this.m_contactManager.Collide();
    var e = new b2Island(
      this.m_bodyCount,
      this.m_contactCount,
      this.m_jointCount,
      this.m_stackAllocator
    );
    for (o = this.m_bodyList; null != o; o = o.m_next)
      o.m_flags &= ~b2Body.e_islandFlag;
    for (var s = this.m_contactList; null != s; s = s.m_next)
      s.m_flags &= ~b2Contact.e_islandFlag;
    for (var a = this.m_jointList; null != a; a = a.m_next) a.m_islandFlag = !1;
    for (
      var l = (this.m_bodyCount, new Array(this.m_bodyCount)), r = 0;
      r < this.m_bodyCount;
      r++
    )
      l[r] = null;
    for (var m = this.m_bodyList; null != m; m = m.m_next)
      if (
        !(
          m.m_flags &
          (b2Body.e_staticFlag |
            b2Body.e_islandFlag |
            b2Body.e_sleepFlag |
            b2Body.e_frozenFlag)
        )
      ) {
        e.Clear();
        var _ = 0;
        for (l[_++] = m, m.m_flags |= b2Body.e_islandFlag; _ > 0; )
          if (
            ((o = l[--_]),
            e.AddBody(o),
            (o.m_flags &= ~b2Body.e_sleepFlag),
            !(o.m_flags & b2Body.e_staticFlag))
          ) {
            for (var h = o.m_contactList; null != h; h = h.next)
              h.contact.m_flags & b2Contact.e_islandFlag ||
                (e.AddContact(h.contact),
                (h.contact.m_flags |= b2Contact.e_islandFlag),
                (n = h.other),
                n.m_flags & b2Body.e_islandFlag ||
                  ((l[_++] = n), (n.m_flags |= b2Body.e_islandFlag)));
            for (var c = o.m_jointList; null != c; c = c.next)
              1 != c.joint.m_islandFlag &&
                (e.AddJoint(c.joint),
                (c.joint.m_islandFlag = !0),
                (n = c.other),
                n.m_flags & b2Body.e_islandFlag ||
                  ((l[_++] = n), (n.m_flags |= b2Body.e_islandFlag)));
          }
        e.Solve(this.step, this.m_gravity),
          (this.m_positionIterationCount = b2Math.b2Max(
            this.m_positionIterationCount,
            b2Island.m_positionIterationCount
          )),
          this.m_allowSleep && e.UpdateSleep(t);
        for (var u = 0; u < e.m_bodyCount; ++u)
          if (
            ((o = e.m_bodies[u]),
            o.m_flags & b2Body.e_staticFlag &&
              (o.m_flags &= ~b2Body.e_islandFlag),
            o.IsFrozen() && this.m_listener)
          ) {
            var y = this.m_listener.NotifyBoundaryViolated(o);
            y == b2WorldListener.b2_destroyBody &&
              (this.DestroyBody(o), (o = null), (e.m_bodies[u] = null));
          }
      }
    this.m_broadPhase.Commit();
  },
  Query: function (t, i, o) {
    for (
      var n = new Array(), e = this.m_broadPhase.QueryAABB(t, n, o), s = 0;
      e > s;
      ++s
    )
      i[s] = n[s];
    return e;
  },
  GetBodyList: function () {
    return this.m_bodyList;
  },
  GetJointList: function () {
    return this.m_jointList;
  },
  GetContactList: function () {
    return this.m_contactList;
  },
  m_blockAllocator: null,
  m_stackAllocator: null,
  m_broadPhase: null,
  m_contactManager: new b2ContactManager(),
  m_bodyList: null,
  m_contactList: null,
  m_jointList: null,
  m_bodyCount: 0,
  m_contactCount: 0,
  m_jointCount: 0,
  m_bodyDestroyList: null,
  m_gravity: null,
  m_allowSleep: null,
  m_groundBody: null,
  m_listener: null,
  m_filter: null,
  m_positionIterationCount: 0,
}),
  (b2World.s_enablePositionCorrection = 1),
  (b2World.s_enableWarmStarting = 1);
var b2WorldListener = new b2Root();
jQuery.extend(b2WorldListener.prototype, {
  NotifyJointDestroyed: function (t) {},
  NotifyBoundaryViolated: function (t) {
    return b2WorldListener.b2_freezeBody;
  },
  initialize: function () {},
}),
  (b2WorldListener.b2_freezeBody = 0),
  (b2WorldListener.b2_destroyBody = 1);
